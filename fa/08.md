# روز ۰۸: مفاهیم پایه و استفاده از شاخه‌ها (Branches)

در Git، **شاخه‌ها** (branches) مکانیزم بسیار مهمی هستند و باید با دقت ویژه از آن‌ها استفاده کرد، زیرا یک پروژه نمی‌تواند تا ابد شاخه‌سازی شود. در نهایت، شاخه‌ها باید ادغام (merge) شوند، اما ادغام موضوعی برای آینده است. این مقاله ابتدا به شما کمک می‌کند تا مفاهیم پایه و نحوه استفاده از شاخه‌های Git را یاد بگیرید.

## مفاهیم پایه شاخه‌ها (Branches)

هدف اصلی استفاده از مکانیزم "شاخه" در کنترل نسخه، حل مشکل تداخل نسخه‌ها (version conflicts) در طول فرآیند توسعه است. من معتقدم بسیاری از افرادی که از هر مکانیزم کنترل نسخه‌ای استفاده کرده‌اند، فکر می‌کنند که "شاخه‌سازی" مقصر اصلی "ایجاد تداخل نسخه‌ها" است، زیرا وقتی شروع به شاخه‌سازی می‌کنید، قطعاً در مورد موضوع ادغام فکر خواهید کرد. پس از شاخه‌سازی، اگر شخصی همان خط از فایلی را که شما تغییر دادید تغییر دهد، باعث ایجاد "تداخل نسخه" می‌شود. هر زمان که تداخلی رخ دهد، باید زحمت حل آن را به جان بخرید.

وقتی تداخلی رخ می‌دهد، گاهی اوقات می‌توانید به راحتی تصمیم بگیرید که از نسخه خودتان یا نسخه طرف مقابل استفاده کنید، اما گاهی اوقات به این راحتی نیست. وقتی وضعیت پیچیده است، باید بر اساس قسمت تداخل یافته، شخصی را که در ابتدا آن خطوط را تغییر داده پیدا کنید، تأثیر تغییرات یکدیگر را بر سیستم هماهنگ کنید و در نهایت تصمیم بگیرید که چگونه ادغام کنید. چنین مشکلاتی بسیار خسته‌کننده هستند، بنابراین بسیاری از افراد سعی می‌کنند از "شاخه‌سازی" اجتناب کنند تا از "تداخل‌ها" دوری کنند.

با این حال، اگر تیم توسعه بزرگتر شود و عملکردهای سیستم بیشتر و بیشتر شود، حتی اگر نسخه را شاخه‌سازی نکنید، تداخل‌های همه افراد باز هم بی‌پایان پدیدار می‌شوند. گاهی اوقات حتی مشکل تداخل نیست، بلکه شخص A عملکردی را تمام کرده و توسط نسخه بعدی شخص B بدون هیچ تداخلی رونویسی شده است، که چیزی نیست که همه بخواهند ببینند. با این حال، این هم یک وضعیت "تداخل نامرئی" است.

در گذشته، در مکانیزم کنترل نسخه متمرکز Subversion نیز مفهوم شاخه‌سازی وجود داشت که می‌توانست بسیار خوب کار کند. البته اگر معماری نرم‌افزاری شما به اندازه کافی خوب نباشد، اگر در مورد مفهوم شاخه‌سازی و استفاده از ابزارها کاملاً شفاف نباشید، معتقدم که استفاده از "شاخه‌سازی" روان نخواهد بود. این یک نتیجه اجتناب‌ناپذیر است. هرگز ابزار کنترل نسخه‌ای در این دنیا وجود نخواهد داشت که به شما اجازه دهد "بدون تلاش، بدون درد، به طور طبیعی شاخه‌سازی را یاد بگیرید." این به افراد بستگی دارد. اگر مفاهیم افراد اشتباه باشد، هیچ ابزاری به آرامی کار نخواهد کرد.

از آنجایی که Git یک "مکانیزم کنترل نسخه توزیع شده" است، در سناریوی مدیریت نسخه توزیع شده، آخرین چیزی که می‌خواهید انجام دهید "مدیریت" است، بنابراین Git به ندرت به اصطلاح مکانیزم‌های مدیریتی یا سیستم‌های کنترل دسترسی دارد. تنها چیزی که می‌خواهد انجام دهد این است که به همه اجازه دهد به راحتی "شاخه‌سازی" و "ادغام" کنند.

با در نظر گرفتن "مخزن راه دور" (remote repository) ذکر شده در [روز ۰۳: ایجاد یک مخزن] به عنوان مثال، می‌توانید تصور کنید: از لحظه‌ای که از دستور `git clone` استفاده می‌کنیم، در واقع شروع "شاخه‌سازی" است. شما یک مخزن کامل را از مخزن راه دور کپی می‌کنید، سپس شروع به ایجاد نسخه‌ها در ماشین محلی خود می‌کنید. پس از اینکه نرم‌افزار تا حد معینی اصلاح شد، آن را "ادغام" می‌کنید. فقط این است که دستور ادغام در این زمان `git push` نامیده می‌شود.

این وضعیتِ شاخه‌سازی و ادغام در همه جای فرآیند کنترل نسخه Git وجود دارد. مخازن راه دور می‌توانند شاخه داشته باشند، مخازن محلی می‌توانند شاخه داشته باشند. شما می‌توانید از هر شاخه راه دور در یک شاخه محلی ادغام (pull) کنید، یا می‌توانید یک شاخه محلی را به یک شاخه راه دور push کنید. البته می‌توانید از هر شاخه محلی در شاخه محلی دیگری نیز ادغام انجام دهید. می‌توان تصور کرد که اگر "شاخه‌سازی" منطق کنترل خوبی نداشته باشد، در نهایت می‌توانید انواع سناریوهای کنترل نسخه فوق‌العاده پیچیده را ترکیب کنید که چیزی نیست که همه بخواهند ببینند. بنابراین، یادگیری خوب "شاخه‌سازی" و "ادغام" واقعاً مهم است. به عنوان مثال، git-flow یک مدل مدیریت شاخه بسیار محبوب است. این یک ابزار نیست، بلکه منطقی برای مدیریت شاخه‌ها است. من این بخش را در مقالات آینده خود توضیح خواهم داد.

در طول توسعه هسته لینوکس، ده‌هفتاد هزار توسعه‌دهنده از سراسر جهان با هم مشارکت داشتند. به منظور مدیریت چنین تیم توسعه بزرگی، Git متولد شد. این یک مکانیزم کنترل نسخه توزیع شده است. همه یک نسخه کامل دارند. پس از توزیع نسخه، همه باید نسخه خود را مدیریت کنند و سپس بر اساس نیازهای تیم آن را ادغام کنند. با این حال، قبل از ادغام مجدد، این مکانیزم تضمین می‌کند که همه می‌توانند به راحتی توسعه دهند بدون اینکه تحت تأثیر نسخه هیچ توسعه‌دهنده دیگری قرار بگیرند. Git واقعاً این کار را انجام داده و در عین حال پیچیدگی کنترل نسخه را نیز کاهش داده است.

البته باید این را هم بگویم که اگر تیمی که در توسعه نرم‌افزار مشارکت می‌کند فقط دو یا سه نفر باشد و این افراد هنوز با هم باشند، در واقع نیازی به استفاده از کنترل نسخه Git نیست. استفاده از Subversion هم انتخاب بسیار خوبی است، ساده و بصری. اگر در طول فرآیند توسعه با مشکلی مواجه شدید، با هماهنگی با اطرافیانتان قابل حل است. این بسیار راحت‌تر از این است که کل تیم را وادار به درک Git کنید.

اگر تیم شما مقیاس خاصی دارد، یا همه با هم کار نمی‌کنند و نیاز به انجام کنترل نسخه دارید، شاید Git انتخاب خوبی باشد. با این حال، داشتن یک مفهوم یا عادت کنترل نسخه هماهنگ در تیم کاری نیز موضوع بسیار مهمی است.

## آماده‌سازی دایرکتوری کاری

ما به سرعت یک مخزن Git و دایرکتوری کاری با دو نسخه از طریق دستورات زیر ایجاد می‌کنیم:

```
mkdir git-branch-demo
cd git-branch-demo
git init

echo. > a.txt
git add .
git commit -m "Initial commit"

echo 1 > a.txt
git add .
git commit -m "a.txt: set 1 as content"
```

سپس از `git log` برای دریافت اطلاعات نسخه به صورت زیر استفاده کنید:

```
C:\demo\git-branch-demo>git log
commit b917758c0f2f347a895ee5bbb5e5c8228f66335a
Author: Will <doggy.huang@gmail.com>
Date:   Fri Oct 4 20:58:16 2013 +0800

    a.txt: set 1 as content

commit aa3e4fe2ee065b046e00a74b1f12a0b0f8154003
Author: Will <doggy.huang@gmail.com>
Date:   Fri Oct 4 20:04:39 2013 +0800

    Initial commit
```

سپس از دستور `git branch` استفاده می‌کنیم تا بدانیم که در حال حاضر شاخه‌ای به نام `master` داریم که شاخه پیش‌فرض در مخزن Git است. اگر بخواهید این شاخه را از طریق `git branch -d master` حذف کنید، پیام خطای `error: Cannot delete the branch 'master' which you are currently on.` را دریافت خواهید کرد. این به این معنی است که "وقتی شاخه دایرکتوری کاری فعلی شما روی master تنظیم شده است، نمی‌توانید شاخه فعلی را حذف کنید،" یعنی باید ابتدا قبل از حذف این شاخه، به "شاخه دیگری" سوئیچ کنید.

![image](figures/08/01.png)

البته ما اکنون فقط یک شاخه داریم، بنابراین طبیعتاً نمی‌توانیم خودمان را حذف کنیم.

## ایجاد شاخه‌ها (Creating Branches)

دو راه رایج برای ایجاد شاخه وجود دارد:

۱. ایجاد یک شاخه، اما نگه داشتن دایرکتوری کاری فعلی در شاخه خودتان: `git branch [BranchName]`

   وقتی دستور `git branch newbranch1` را اجرا می‌کنم، این یک شاخه جدید به نام `newbranch1` ایجاد می‌کند. سپس از `git branch` استفاده می‌کنیم تا ببینیم در حال حاضر چند شاخه وجود دارد. دو تا خواهید دید، اما دایرکتوری کاری فعلی همچنان در شاخه `master` باقی می‌ماند، همانطور که در شکل زیر نشان داده شده است:

   ![image](figures/08/02.png)

   اگر در این زمان یک نسخه در دایرکتوری کاری فعلی ایجاد کنید، در شاخه `master` ایجاد خواهد شد. ما در این زمان یک فایل جدید ایجاد می‌کنیم و از طریق `git commit` یک نسخه می‌سازیم. دستورات به شرح زیر است:

   ```
    echo master > b.txt
    git add .
    git commit -m "Create b.txt with content 'master' in the master branch"
   ```

   لطفاً به یاد داشته باشید: ما ابتدا دو نسخه در شاخه پیش‌فرض `master` ایجاد کردیم، سپس یک شاخه ساختیم و سپس نسخه دیگری در شاخه `master` ایجاد کردیم.

۲. ایجاد یک شاخه و سوئیچ کردن دایرکتوری کاری فعلی به شاخه جدید: `git checkout -b [BranchName]`

   در مرحله بعد، با استفاده از روش دوم یک شاخه ایجاد می‌کنیم. وقتی دستور `git checkout -b newbranch2` را اجرا می‌کنم، نه تنها یک شاخه جدید ایجاد می‌شود، بلکه دایرکتوری کاری فعلی نیز به شاخه دیگر سوئیچ می‌شود. در نهایت، از `git branch` استفاده کنید تا ببینید در حال حاضر چند شاخه وجود دارد. خواهید دید که در حال حاضر سه تا وجود دارد و دایرکتوری کاری فعلی به شاخه `newbranch2` که به تازگی ایجاد شده است سوئیچ شده است، همانطور که در شکل زیر نشان داده شده است:

   ![image](figures/08/03.png)

   اگر در این زمان نسخه‌ای در دایرکتوری کاری فعلی ایجاد کنید، در شاخه `newbranch2` ایجاد خواهد شد. ما در این زمان یک فایل جدید می‌سازیم و از طریق `git commit` یک نسخه ایجاد می‌کنیم. دستورات به شرح زیر است:

   ```
    echo newbranch2 > b.txt
    git add .
    git commit -m "Modify b.txt with content 'newbranch2' in the newbranch2 branch"
   ```

   لطفاً به یاد داشته باشید: ما ابتدا دو نسخه در شاخه پیش‌فرض `master` ایجاد کردیم، سپس یک شاخه ساختیم، سپس نسخه دیگری در شاخه `master` ایجاد کردیم، سپس بر اساس وضعیت فعلی شاخه `master` یک شاخه جدید `newbranch2` ایجاد کردیم، دایرکتوری کاری را به شاخه `newbranch2` سوئیچ کردیم و سپس نسخه دیگری ایجاد کردیم. اگر در این زمان `git log` را اجرا کنیم، ۴ رکورد نسخه نمایش داده می‌شود زیرا شاخه به طور خودکار تاریخچه کامل شاخه منبع را به ارث می‌برد.

**توجه**: برای توضیحات دقیق دستورات و پارامترها، می‌توانید دستور `git help branch` را برای مشاهده مستندات کامل وارد کنید.

```
git branch [branch_name]
```

## سوئیچ کردن شاخه‌ها (Switching Branches)

اگر می‌خواهید دایرکتوری کاری را به شاخه دیگری سوئیچ کنید، می‌توانید دستور زیر را (بدون پارامتر `-b`) وارد کنید:

```
git checkout [branch_name]
```

با فرض اینکه می‌خواهیم دایرکتوری کاری را به شاخه `newbranch1` سوئیچ کنیم، می‌توانیم `git checkout newbranch1` را وارد کنیم تا جابجا شویم. سپس بلافاصله می‌توانید از `git branch` استفاده کنید تا بررسی کنید آیا دایرکتوری کاری فعلی جابجا شده است یا خیر، و بعد از `git log` برای بررسی سوابق تاریخی شاخه `newbranch1` فعلی استفاده کنید. چون این اولین شاخه‌ای است که ایجاد کردیم، از نظر تئوری این وضعیت شاخه باید فقط دو رکورد تاریخی داشته باشد، همانطور که در شکل زیر نشان داده شده است:

![image](figures/08/04.png)

**توجه**: برای توضیحات دقیق دستورات و پارامترها، می‌توانید دستور `git help checkout` را برای مشاهده مستندات کامل وارد کنید.

```
git checkout [branch_name]
```

## حذف شاخه‌ها (Deleting Branches)

اگر می‌خواهید یک شاخه موجود را حذف کنید، همانطور که در بخش **آماده‌سازی دایرکتوری کاری** اشاره کردیم، دستور به شرح زیر است:

```
git branch -d [branch_name]
```

همچنین قبلاً ذکر شد که نمی‌توانید شاخه‌ای را که توسط دایرکتوری کاری فعلی مشخص شده است حذف کنید. قبل از حذف شاخه فعلی خود، ابتدا باید به شاخه دیگری سوئیچ کنید. به عنوان مثال، اگر می‌خواهید شاخه فعلی `newbranch1` را حذف کنید، باید ابتدا به شاخه دیگری مانند شاخه `master` سوئیچ کنید و سپس دستور `git branch -d newbranch1` را برای حذف شاخه اجرا کنید، همانطور که در شکل زیر نشان داده شده است:

![image](figures/08/05.png)

## بررسی اینکه دایرکتوری کاری در کدام شاخه است

می‌توانید از دستور `git branch` استفاده کنید تا ببینید در حال حاضر در کدام شاخه هستید، همانطور که در شکل زیر نشان داده شده است:

![image](figures/08/06.png)

## مشاهده نمودار کامل شاخه‌های مخزن Git

در نهایت، من از ابزار SourceTree برای نمایش نمودار شاخه فعلی مخزن Git استفاده می‌کنم. در حال حاضر ما فقط دو شاخه داریم، یکی شاخه `master` و دیگری شاخه `newbranch2` است، زیرا شاخه `newbranch1` در طول تمرین حذف شد. به منظور اینکه به شاخه‌هایمان حس یک "درخت" بدهیم، در مرحله بعد نحوه بازسازی شاخه‌ای با وضعیتی مشابه `newbranch1` قبلی و اضافه کردن یک نسخه جدید تحت این شاخه را نشان خواهم داد.

نمی‌دانم هنوز یادتان هست یا نه، ما شاخه `newbranch1` را پس از ایجاد دو نسخه در شاخه `master` ایجاد کردیم. حالا بیایید ابتدا id شیء کامیت این نسخه را پیدا کنیم که از طریق `git log` قابل دستیابی است، همانطور که در شکل زیر نشان داده شده است:

![image](figures/08/07.png)

بنابراین commit object id من عبارت است از: b917758c0f2f347a895ee5bbb5e5c8228f66335a

سپس ابتدا دایرکتوری کاری را به این نسخه سوئیچ می‌کنم که از طریق `git checkout [commit_id]` قابل انجام است:

```
git checkout b917758c0f2f347a895ee5bbb5e5c8228f66335a
```

در این زمان، اگر از `git log` استفاده کنید، باید فقط دو رکورد نسخه را ببینید زیرا ما حالت دایرکتوری کاری را به این نسخه سوئیچ کرده‌ایم. از شکل زیر می‌توانید ببینید که وقتی `git checkout b917758c0f2f347a895ee5bbb5e5c8228f66335a` را اجرا می‌کنیم، تعدادی پیام ظاهر می‌شود. این پیام‌ها بسیار مهم هستند و باید درک شوند، همانطور که در شکل زیر نشان داده شده است:

![image](figures/08/08.png)

اولاً، از آنجایی که نسخه دایرکتوری کاری را به یک نسخه "قدیمی" سوئیچ می‌کنید، به شما هشدار داده می‌شود که این دایرکتوری کاری وارد وضعیت به اصطلاح **detached HEAD** شده است. این یادآوری است که "دایرکتوری کاری فعلی در آخرین نسخه نیست." شما می‌توانید در هر زمان به هر نسخه‌ای از مخزن Git سوئیچ کنید، اما چون این نسخه قبلاً یک "نسخه بعدی" دارد، اگر در "نسخه قدیمی" فعلی `git commit` را اجرا کنید، این نسخه جدید برای تغییرات ردیابی نمی‌شود، بنابراین توصیه می‌شود این کار را انجام ندهید.

اگر می‌خواهید یک نسخه قابل ردیابی در وضعیت **detached HEAD** ایجاد کنید، روش صحیح ردیابی از طریق "ایجاد یک شاخه" است. اکنون یک شاخه جدید `newbranch1` در این نسخه ایجاد می‌کنیم و دایرکتوری کاری را به آن منتقل می‌کنیم. دستور به شرح زیر است:

```
git checkout -b newbranch1
```

![image](figures/08/09.png)

سپس یک فایل جدید `b.txt` با محتوای `newbranch1` ایجاد می‌کنیم و یک نسخه جدید می‌سازیم. دستورات به صورت زیر است:

```
echo newbranch1 > b.txt
git add .
git commit -m "Add b.txt in newbranch1"
```

بسیار خب، ما اکنون علاوه بر `master` دو شاخه دیگر داریم و هر دو شاخه نسخه‌های خاص خود را دارند. فکر کنید این درخت در ذهن شما چگونه به نظر می‌رسد!

در مرحله بعد، ابزار SourceTree را باز کرده و این دایرکتوری کاری را به ابزار مدیریت SourceTree اضافه می‌کنیم:

![image](figures/08/10.png)

![image](figures/08/11.png)

پس از اضافه کردن، به شاخه‌های این مخزن Git سوئیچ می‌کنیم. در کل سه تا وجود دارد. بیایید به هر کدام سوئیچ کنیم:

![image](figures/08/12.png)

![image](figures/08/13.png)

![image](figures/08/14.png)

قدیمی‌ترین نسخه در پایین و جدیدترین نسخه در بالا قرار دارد. وقتی به شاخه‌های مختلف سوئیچ می‌کنیم، می‌بینید که سه نمودار شاخه یکسان هستند، فقط "نوار روشن" (light bar) پیش‌فرض متفاوت است. اولاً، آنچه از تصاویر می‌بینید "کل مخزن Git" با تمام نسخه‌ها، تمام شاخه‌ها و اینکه شاخه از کدام نسخه شروع شده است، می‌باشد. "نوار روشن" نشان‌دهنده این است که "آخرین نسخه" از آن شاخه در کدام نسخه در کل مخزن Git قرار دارد.

## خلاصه امروز

در واقع، استفاده از شاخه‌ها در Git کار آسانی است. بخش دشوار این است که به همه بفهمانیم "شاخه‌سازی" چه کاری انجام می‌دهد و آیا **تصور** همه از "شاخه‌سازی" هماهنگ است یا خیر. تا زمانی که تصور همه از شاخه‌سازی هماهنگ باشد، شکاف زیادی در کنترل نسخه تیمی وجود نخواهد داشت.

برای من، شاخه را به عنوان نوعی ویژگی "اسنپ‌شات" (snapshot) تصور می‌کنم که اسنپ‌شاتی از یک نسخه کامیت خاص و نسخه‌های تاریخی آن ایجاد می‌کند، سپس یکی کپی می‌کند و نام شاخه را به آن می‌دهد. می‌توانید نسخه‌هایی روی این شاخه‌ها ایجاد کنید و منتظر ادغام در آینده باشید.

کل مخزن Git تمام شاخه‌ها و نسخه‌ها را حفظ خواهد کرد و در نهایت یک نمودار شاخه با ساختار درختی ارائه می‌دهد. در نهایت، از طریق ابزار SourceTree، می‌توانیم به وضوح وضعیت شاخه‌ها و تغییرات نسخه را در مخزن Git ببینیم. من این نمودار را خیلی زود دیدم، اما اولین باری که به آن نگاه کردم، اصلاً نتوانستم آن را درک کنم. فقط فکر می‌کردم "یک نمودار" است و هیچ حسی به آن نداشوی. اما از زمانی که بیشتر و بیشتر در مورد Git یاد گرفتم، این نمودار شاخه به من اجازه می‌دهد تا تغییرات کل مخزن Git را در یک نگاه درک کنم و مدیریت تغییرات نسخه Git را بهتر در دست بگیرم.

امیدوارم از طریق متن و دموهای دستوری من به همراه تصاویر، بتوانم به شما کمک کنم تا ساختار شاخه‌ای را در ذهن خود ترسیم کنید و درک عمیق‌تری از ساختار شاخه‌های Git داشته باشید.

اجازه دهید دستورات گیت و پارامترهای یاد گرفته شده امروز را دوباره سازماندهی کنم:

* git branch
* git branch [branch_name]
* git checkout -b [branch_name]
* git checkout [branch_name]
* git branch -d [branch_name]
* git log

---

* [بازگشت به فهرست مطالب](README.md)
* [روز قبل: تجزیه ساختار داده Git - ساختار ایندکس (Index Structure)](07.md)
* [روز بعد: مقایسه تفاوت‌های فایل و نسخه](09.md)

---
