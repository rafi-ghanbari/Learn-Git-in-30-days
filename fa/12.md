# روز ۱۲: درک نام‌های نسبی اشیاء Git (Git Object Relative Names)

پس از درک "نام‌های مطلق" و "نام‌های مرجع" اشیاء Git، اکنون "نام‌های نسبی" را معرفی خواهیم کرد که آن‌ها نیز معمولاً در فرآیند کنترل نسخه Git استفاده می‌شوند.

بیایید دوباره مرور کنیم. در کنترل نسخه Git، هر نسخه نشان‌دهنده یک شیء کامیت (commit object) است. هر شیء کامیت دارای یک "نام مطلق" است - یک رشته ۴۰ کاراکتری که از طریق هش SHA1 محتوا به دست می‌آید. شما می‌توانید از ۴ تا ۴۰ کاراکتر اول به عنوان نام شناسایی آن شیء کامیت استفاده کنید. در طول کنترل نسخه، شما همچنین می‌توانید از "نام‌های مرجع" برای نشان دادن یک شیء کامیت خاص استفاده کنید. هر "نام مرجع" در نهایت با "نام مطلق" یک شیء مطابقت دارد. "نام‌های مرجع" خود به دو دسته "مراجع عمومی" و "مراجع نمادین" تقسیم می‌شوند. در میان آن‌ها، "مراجع عمومی" مستقیماً با "نام‌های مطلق" مطابقت دارند، در حالی که "مراجع نمادین" با یک "مرجع عمومی" دیگر مطابقت دارند.

آنچه در این مقاله معرفی خواهد شد، استفاده از نمادگذاری "نام نسبی" است که به شما امکان می‌دهد پس از یافتن یک شیء کامیت خاص، سایر "اشیاء کامیت" را بر اساس موقعیت نسبی آن‌ها پیدا کنید.

## نمادگذاری نام نسبی (Relative Name Notation)

استفاده از نام‌های نسبی در واقع بسیار ساده است. دو نماد خاص وجود دارد که باید به خاطر بسپارید، یکی `^` و دیگری `~`.

برای یافتن نسخه قبلیِ `HEAD` از `HEAD~` یا `HEAD~1` استفاده می‌کنیم که نشان‌دهنده "نسخه قبلیِ شیء کامیتِ HEAD" است. **توجه**: در اینجا باید به خوبی بدانید که `HEAD` یک "نام مرجع نمادین" داخلی در Git است که نشان‌دهنده آخرین نسخه شاخه فعلی است.

اگر می‌خواهید دو نسخه قبل از شاخه `f2e` دیگر را پیدا کنید (بدون شامل شدن نسخه `HEAD` از `f2e`)، می‌توانید از `f2e~2` یا `f2e~~` برای نمایش آن استفاده کنید. این ابتدایی‌ترین روش نمایش است.

در مخازنی بدون شاخه‌سازی و ادغام (merging)، معنای بیان شده توسط `1^` و `1~` دقیقاً یکسان است و هر دو نشان‌دهنده "نسخه قبلی" هستند. اما در واقع، در مخازنی با شاخه‌سازی و ادغام، آن‌ها معانی متفاوتی دارند. این بخش بعداً توضیح داده خواهد شد.

این ابتدایی‌ترین نمادگذاری "نام نسبی" است.

## پیوندهای بین اشیاء کامیت (Links Between Commit Objects)

در بیشتر مخازن رایج Git، به طور پیش‌فرض فقط یک "شیء کامیت ریشه" (root commit object) وجود خواهد داشت که همان اولین نسخه‌ای است که ایجاد کردیم و به عنوان "Initial Commit" نیز شناخته می‌شود. شما همچنین باید حداقل اولین شیء کامیت را داشته باشید تا بتوانید شاخه‌سازی را شروع کنید. بنابراین می‌توانیم بگوییم: "در یک مخزن Git، از بین تمام اشیاء کامیت، به جز اولین شیء کامیت، هر شیء کامیت دیگری باید یک یا چند شیء کامیت والد (parent commit object) داشته باشد." چرا ممکن است "بیش از یک" شیء کامیت والد وجود داشته باشد؟ زیرا به احتمال زیاد دو یا چند شاخه را در شاخه دیگری ادغام می‌کنید. بنابراین شیء کامیت پس از ادغام چندین شیء کامیت والد خواهد داشت.

بیایید از یک مثال ساده برای اثبات این موضوع استفاده کنیم. ما از `git cat-file -p [object_id]` برای دریافت محتوای دو شیء کامیت اول استفاده می‌کنیم و در نتیجه درک می‌کنیم که هر شیء کامیت در واقع دارای یک ویژگی والد (parent) است که به نام مطلقِ شیء کامیتِ والد اشاره می‌کند، به جز اولین شیء کامیت که ویژگی والد نخواهد داشت. همانطور که در شکل زیر نشان داده شده است:

![image](figures/12/01.png)

## درک تفاوت بین `^` و `~` در نمادگذاری نام نسبی

معنای `~` نشان‌دهنده "اولین شیء کامیتِ والد" است.

معنای بیان شده توسط `^` این است که "زمانی که چندین شیء کامیتِ والد وجود دارد، کدامین والدِ نسل اول را نشان دهد."

اگر "نام مرجعی" به نام `C` دارید، برای یافتن اولین شیء کامیتِ والدِ آن، می‌توانید عبارات زیر را داشته باشید:

* `C^`
* `C^1`
* `C~`
* `C~1`

اگر می‌خواهید دومین شیء کامیتِ والدِ آن را پیدا کنید (بدون ادغام)، می‌توانید عبارات زیر را داشته باشید:

* `C^^`
* `C^1^1`
* `C~2`
* `C~~`
* `C~1~1`

اما نمی‌توانید از `C^2` برای بیان "دومین شیء کامیتِ والد" استفاده کنید! دلیل آن این است که بدون ادغام، این `C` فقط یک شیء والد دارد. شما فقط می‌توانید از `C^2` برای نشان دادن "دومین شیء والدِ شیءِ لایه قبلی" استفاده کنید.

موارد فوق ممکن است کمی انتزاعی و پیچیده به نظر برسند. من به طور ویژه نموداری برای شما کشیدم تا ببینید. از طریق نمودار، ممکن است واضح‌تر باشد. همانطور که در شکل زیر نشان داده شده است، ما می‌خواهیم سایر اشیاء کامیت (اشیاء والد) را در مسیر نسبیِ شیء کامیتِ `C` پیدا کنیم. از آنجایی که این شیء کامیتِ `C` دارای سه شیء والد است، به این معنی است که این شیء کامیت از طریق ادغام ایجاد شده است. سپس برای یافتن هر مسیر از طریق "نام‌های نسبی"، باید از ترکیبی از مهارت‌های `^` و `~` برای مکان‌یابی هر نسخه‌ای که می‌خواهید باز کنید، استفاده کنید.

![image](figures/12/02.png)

## معرفی دستور git rev-parse

در ابزار Git for Windows، دستوری به نام `git rev-parse` وجود دارد. از طریق این دستور، می‌توانید هر "نام مرجع" یا "نام نسبی" را به یک "نام مطلق" تجزیه کنید. اگرچه از این ابزار زیاد استفاده نمی‌شود، اما هنگام آموزش Git بسیار کاربردی است. مثال‌های استفاده به شرح زیر است:

* git rev-parse master
* git rev-parse HEAD
* git rev-parse ORIG_HEAD
* git rev-parse HEAD^
* git rev-parse HEAD~5

## خلاصه امروز

پس از درک "نام‌های نسبی"، روش‌های مختلف نمایش اشیاء کامیت در Git توضیح داده شده است. من معتقدم که باید بتوانید عملیات بین نسخه‌های مختلف Git را بهتر کنترل کنید.

اجازه دهید دستورات گیت و پارامترهای یاد گرفته شده امروز را دوباره سازماندهی کنم:

* git log
* git cat-file -p [object_id]
* git rev-parse

---

* [بازگشت به فهرست مطالب](README.md)
* [روز قبل: درک مراجع شیء Git و مراجع نمادین](11.md)
* [روز بعد: ذخیره‌سازی تغییرات در دایرکتوری کاری و ایندکس (Stash)](13.md)

---
