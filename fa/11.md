# روز ۱۱: درک مراجع شیء Git و مراجع نمادین (Object References and Symbolic References)

پس از درک "نام‌های مطلق" اشیاء Git، در مرحله بعد پرکاربردترین "نام‌های مرجع" در فرآیند کنترل نسخه Git را معرفی خواهیم کرد.

## درک نام‌های مرجع اشیاء (Object Reference Names)

نام‌های مرجع (ref) به سادگی یک "اشاره‌گر" (pointer) به اشیاء Git یا "نامی ماندگار در حافظه" در مقایسه با "نام‌های مطلق" هستند. آن‌ها از یک نام از پیش تعریف شده یا تعریف شده توسط کاربر برای نشان دادن یک شیء خاص Git استفاده می‌کنند.

"نام‌های شاخه" که قبلاً یاد گرفتیم، `HEAD` که استفاده کرده‌ایم (نشان‌دهنده آخرین نسخه)، یا "نام‌های تگ" که بعداً یاد خواهیم گرفت - این‌ها همگی "نام‌های مرجع" هستند که اساساً برای آسان‌تر کردن به خاطر سپاری ایجاد شده‌اند.

ما از "نام‌های شاخه" به عنوان مثال استفاده می‌کنیم تا توضیح دهیم ساختار فیزیکی "نام‌های مرجع" چیست. در شکل زیر، ما از `git branch` برای دریافت تمام نام‌های شاخه استفاده می‌کنیم. می‌بینید که در حال حاضر سه شاخه داریم. با این حال، این سه نام شاخه در واقع "نام‌های مرجع" هستند، به این معنی که این سه "نام مرجع" با سه شیء کامیت در مخزن اشیاء Git مطابقت دارند. در شکل زیر، همچنین می‌توانید ببینید که این نام‌های مرجع شاخه در واقع فقط فایل هستند. تمام نام‌های مرجع "شاخه محلی" در دایرکتوری `.git\refs\heads` قرار دارند:

![image](figures/11/01.png)

سپس از شکل زیر استفاده می‌کنم تا ثابت کنم چگونه این فایل به "نام مطلق" پیوند خورده است. من ابتدا از `git branch` برای دریافت تمام نام‌های شاخه استفاده می‌کنم و متوجه می‌شوم که "دایرکتوری کاری" فعلی به شاخه `newbranch1` اشاره می‌کند. در این زمان، می‌توانیم تمام رکوردهای نسخه این شاخه را از طریق `git log --pretty=oneline` دریافت کنیم. به طور پیش‌فرض، این "نام‌های مرجع" شاخه به "آخرین نسخه" شاخه اشاره می‌کنند. ما فقط باید محتوای فایل `.git\refs\heads\newbranch1` را باز کنیم تا ببینیم که این فقط یک فایل متنی ساده است که به "آخرین نسخه" در تاریخچه نسخه اشاره می‌کند. در نهایت، از `git cat-file -p 0bd0` برای دریافت محتوای آن شیء کامیت و `git show 0bd0` برای دریافت سوابق تغییرات آن نسخه استفاده می‌کنیم و در نتیجه ثابت می‌کنیم که این فایل‌ها هدف اصلی "نام‌های مرجع" هستند.

![image](figures/11/02.png)

سپس از دستوراتی برای دیدن محتوای خواندن یک شیء کامیت خاص با استفاده از "نام‌های مطلق" و "نام‌های مرجع" استفاده می‌کنیم که ثابت می‌کند نتایج این دو دستور یکسان است:

![image](figures/11/03.png)

در بیشتر موارد، "نام‌های مرجع" معمولاً به یک شیء کامیت اشاره می‌کنند، اما این کار ضروری نیست. شما همچنین می‌توانید به انواع دیگر اشیاء Git، مانند اشیاء blob، اشیاء درختی، اشیاء تگ و غیره اشاره کنید.

## درباره دایرکتوری .git/refs/

از مثال‌های بالا، در واقع می‌توانید ببینید که تمام "نام‌های مرجع" فایل هستند و همگی در دایرکتوری `git/refs/` قرار دارند. محل دایرکتوری‌هایی که نام‌های مرجع Git در آن‌ها قرار می‌گیرند عمدتاً سه مورد است:

* شاخه‌های محلی (Local branches): `.git/refs/heads/`
* شاخه‌های راه دور (Remote branches): `.git/refs/remotes/`
* تگ‌ها (Tags): `.git/refs/tags/`

اجازه دهید یک مثال ساده بزنم. اگر شاخه‌ای به نام `f2e` ایجاد کنید، در این زمان خواهید دید که "نام مرجع" شاخه محلی فایل `.git/refs/heads/f2e` را ایجاد می‌کند، همانطور که در شکل زیر نشان داده شده است:

![image](figures/11/04.png)

در واقع، "نام کامل" این `f2e` باید `refs/heads/f2e` نامیده شود. فقط این است که Git به شما اجازه می‌دهد تا اختصارات را برای تسهیل ورودی سریع نام‌های مرجع وارد کنید. همانطور که در شکل زیر نشان داده شده است، این سه روش استفاده از "نام‌های مرجع" همگی امکان‌پذیر هستند:

![image](figures/11/05.png)

با این حال، زمانی که "اختصار" نام مرجع را وارد می‌کنید، Git به طور پیش‌فرض در ترتیب زیر به دنبال نام مرجع مناسب می‌گردد. به محض اینکه فایل مربوطه پیدا شد، بلافاصله "نام مطلق شیء" محتوای آن فایل را برمی‌گرداند:

* `.git/<اختصار مرجع>`
* `.git/refs/<اختصار مرجع>`
* `.git/refs/tags/<اختصار مرجع؛ نام تگ>`
* `.git/refs/heads/<اختصار مرجع؛ نام شاخه محلی>`
* `.git/refs/remotes/<اختصار مرجع>`
* `.git/refs/remotes/<اختصار مرجع؛ نام شاخه راه دور>/HEAD`

به عنوان مثال، وقتی دستور `git cat-file -p f2e` را وارد می‌کنید، Git فایل مرجع مربوطه را به ترتیب زیر پیدا کرده و محتوای آن فایل (یعنی نام مطلق شیء Git) را استخراج می‌کند:

* `.git/f2e`  --> فایل پیدا نشد
* `.git/refs/f2e` --> فایل پیدا نشد
* `.git/refs/tags/f2e` --> فایل پیدا نشد
* `.git/refs/heads/f2e` --> **نام مرجع پیدا شد، جستجوی بیشتر متوقف می‌شود**
* `.git/refs/remotes/f2e`
* `.git/refs/remotes/f2e/HEAD`

## درک نام‌های مرجع نمادین اشیاء (Symbolic Reference Names - symref)

نام‌های مرجع نمادین (symref) در واقع نوعی نام مرجع (ref) هستند، فقط با محتوایی متفاوت. تفاوت در محتوا را می‌توانیم در شکل زیر ببینیم. "مراجع نمادین" به نام مرجع دیگری اشاره می‌کنند و محتوای آن‌ها با `:ref` شروع می‌شود:

![image](figures/11/06.png)

در ابزارهای Git، برخی از مراجع نمادین خاص به طور پیش‌فرض برای تسهیل دسترسی سریع به اشیاء کامیت پرکاربرد نگهداری می‌شوند و این اشیاء به طور پیش‌فرض در دایرکتوری `.git/` ذخیره می‌شوند. این مراجع نمادین چهار مورد زیر هستند:

* HEAD
* همیشه به "آخرین نسخه" در "شاخه" تنظیم شده در "دایرکتوری کاری" اشاره می‌کند.
* بنابراین وقتی `git commit` را در این شاخه اجرا می‌کنید، این مرجع نمادین `HEAD` نیز به آن شیء کامیتِ آخرین نسخه این شاخه به‌روزرسانی می‌شود.
* ORIG_HEAD
* به سادگی، این "نسخه قبلیِ" شیء کامیتِ HEAD است که اغلب برای بازیابی تغییرات نسخه قبلی استفاده می‌شود.
* FETCH_HEAD
* هنگام استفاده از یک مخزن راه دور (remote repository)، ممکن است از دستور `git fetch` برای بازیابی تمام اشیاء از مخزن راه دور استفاده کنید. این مرجع نمادین FETCH_HEAD "نام مطلق" HEAD (آخرین نسخه) هر شاخه در مخزن راه دور را ثبت می‌کند.
* MERGE_HEAD
* هنگامی که عملیات ادغام (merge) را انجام می‌دهید (موضوع ادغام در مقالات آینده ذکر خواهد شد)، نام مطلق شیء کامیتِ منبع ادغام در این مرجع نمادین MERGE_HEAD ثبت می‌شود.

## نحوه استفاده از مراجع عمومی و مراجع نمادین

ما می‌دانیم که "نام‌های مرجع" اهداف خاصی دارند و معمولاً در سناریوهایی مانند "شاخه‌های محلی"، "شاخه‌های راه دور" و "تگ‌ها" استفاده می‌شوند، اما در واقع می‌توانید هر تعداد "نام مرجع سفارشی" ایجاد کنید. شما می‌توانید آزادانه مراجع عمومی را از طریق `git update-ref` ایجاد کنید.

من سعی می‌کنم یک مرجع عمومی به نام `InitialCommit` ایجاد کنم و به اولین نسخه در مخزن Git اشاره کنم. لطفاً برای یادگیری نحوه ایجاد مراجع عمومی به توالی اجرای دستورات در شکل زیر مراجعه کنید:

![image](figures/11/07.png)

پس از ایجاد، فایل پیش‌فرض در پوشه `.git` قرار می‌گیرد و در این زمان، می‌توانید با هر دو "نام مطلق" و "نام مرجع" به محتوای اشیاء خاص Git دسترسی پیدا کنید:

![image](figures/11/08.png)

**توجه**: لطفاً به یاد داشته باشید که نام‌های مرجع می‌توانند به هر شیء Git اشاره کنند و محدود به اشیاء کامیت نیستند.

برای ایجاد یک نام مرجع رسمی‌تر، بهتر است پیشوند `/refs` را اضافه کنید، به عنوان مثال: `git update-ref refs/InitialCommit [object_id]`.

برای حذف یک مرجع عمومی، می‌توانید از گزینه `-d` استفاده کنید، همانطور که در شکل زیر نشان داده شده است:

![image](figures/11/09.png)

برای نمایش تمام مراجع، می‌توانید از دستور `git show-ref` استفاده کنید، همانطور که در شکل زیر نشان داده شده است:

![image](figures/11/10.png)

برای ایجاد و حذف "مراجع نمادین"، می‌توانید برای نحوه استفاده از `git symbolic-ref` به شکل زیر مراجعه کنید. لطفاً به تصویر نگاه کرده و داستان را دنبال کنید. پس از درک، واقعاً متوجه خواهید شد که Git در استفاده از مراجع بسیار منعطف و قدرتمند است. همچنین، اجرای `git show-ref` فقط مراجعی را که در دایرکتوری `.git\refs` هستند نمایش می‌دهد و برای هر دو مورد "مراجع عمومی" و "مراجع نمادین" یکسان است:

![image](figures/11/11.png)

پیش از این در این مقاله ذکر شد که می‌توانید مراجعی را در دایرکتوری‌های زیر ایجاد کنید:

* `.git/<اختصار مرجع>`
* `.git/refs/<اختصار مرجع>`
* `.git/refs/tags/<اختصار مرجع؛ نام تگ>`
* `.git/refs/heads/<اختصار مرجع؛ نام شاخه محلی>`
* `.git/refs/remotes/<اختصار مرجع>`
* `.git/refs/remotes/<اختصار مرجع؛ نام شاخه راه دور>/HEAD`

مراجع سفارشی معمولاً در دو مسیر اول ایجاد می‌شوند تا با استفاده ما از "شاخه‌های محلی"، "شاخه‌های راه دور" و "تگ‌ها" اشتباه نشوند. با این حال، شما واقعاً می‌توانید از `git update-ref` برای ایجاد هر مرجع سفارشی استفاده کنید. اگر یک مرجع سفارشی در `refs/heads/Will` ایجاد کنید، معادل ایجاد شاخه‌ای به نام `Will` است. گیت واقعاً به همین سادگی است. هر چه بیشتر ساختار داخلی Git را درک کنید، بیشتر عاشق ویژگی‌های مختلف آن خواهید شد.

## خلاصه امروز

ما می‌دانیم که "نام‌های مرجع (ref)" به سادگی یک "اشاره‌گر" به اشیاء Git هستند که برای اشاره به اشیاء خاص Git استفاده می‌شوند. بنابراین می‌توانید "نام‌های مرجع" را به عنوان نام مستعار برای نام‌های مطلق اشیاء Git تصور کنید که برای کمک به حافظه استفاده می‌شوند. در Git، مکانیزم‌های زیادی برای کمک به شما در کنترل پروژه‌ها وجود دارد، مانند "شاخه‌ها"، "تگ‌ها" و غیره. این مکانیزم‌ها در واقع توسط "مراجع" در پس‌زمینه انجام می‌شوند.

نام‌های مرجع Git به دو دسته "مراجع عمومی" و "مراجع نمادین" تقسیم می‌شوند. هر دو هدف یکسانی دارند، فقط محتوای آن‌ها کمی متفاوت است. "مراجع نمادین" به "مرجع عمومی" دیگری اشاره می‌کنند، در حالی که "مراجع عمومی" به "نام مطلق" یک شیء Git اشاره دارند.

اجازه دهید دستورات گیت و پارامترهای یاد گرفته شده امروز را دوباره سازماندهی کنم:

* git branch
* git log --pretty=oneline
* git log --oneline
* git cat-file -p [ref or object_id]
* git show [ref or object_id]
* git update-ref
* git symbolic-ref
* git show-ref

---

* [بازگشت به فهرست مطالب](README.md)
* [روز قبل: درک نام‌های مطلق اشیاء Git](10.md)
* [روز بعد: درک نام‌های نسبی اشیاء Git](12.md)

---
