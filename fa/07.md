# روز ۰۷: تجزیه ساختار داده Git - ساختار ایندکس (Index Structure)

ما می‌دانیم که دو ساختار داده مهم در Git وجود دارد، یعنی "اشیاء" (objects) و "ایندکس" (index). این مقاله عمدتاً برای توضیح جزئیات "ایندکس" استفاده می‌شود. در طول فرآیند استفاده از کنترل نسخه Git، ممکن است به راحتی نحوه استفاده از دستورات git را درک کنید، اما به سادگی در دام حفظ کردن طوطی‌وار بیفتید و نتوانید به صورت منعطف از آن‌ها استفاده کنید. حتی لینوس توروالدز در لیست پستی (Mailing List) ذکر کرده است: "قبل از اینکه کاربران معنای ایندکس را درک کنند، نمی‌توانند توانایی‌های Git را به طور کامل بفهمند." بنابراین، درک هدف "ایندکس" بسیار مهم است.

## درباره ایندکس (Index)

به سادگی، هدف از "ایندکس" عمدتاً ثبت این است که "کدام فایل‌ها قرار است در نسخه commit بعدی ثبت شوند".

به عبارت دیگر، "اگر می‌خواهید یک نسخه را در مخزن Git ثبت کنید، ابتدا باید وضعیت ایندکس را به‌روزرسانی کنید تا تغییرات ثبت شوند."

این "ایندکس" در واقع نام‌های مستعار زیادی در بسیاری از مقالات خارجی دارد، اما همه آن‌ها یک معنا دارند. وقتی در آینده کلمات مرتبط را می‌بینید گیج نشوید.

* Index
* Cache
* Directory cache
* Current directory cache
* Staging area
* Staged files

به عنوان مثال، دستور `git diff --cached` کاملاً مترادف با `git diff --staged` است.

## دستورات کار با ایندکس

از آنجایی که "ایندکس" برای Git بسیار مهم است، اکثر دستورات پارامترهای مرتبط با ایندکسِ Git دارند. با این حال، ما به طور خلاصه چند دستور را که مستقیماً با "ایندکس" مرتبط هستند برای توضیح لیست می‌کنیم.

قبل از توضیح دستورات، می‌توانید ابتدا به نمودار زیر نگاه کنید که چرخه عمر تغییر حالت‌ها را از طریق دستورات نشان می‌دهد. در واقع، تمام این فرآیندهای تغییر، فرآیندهای به‌روزرسانی "فایل ایندکس" هستند:

![image](figures/07/01.png)

ابتدا اجازه دهید چهار حالت فایل را معرفی کنم:

* untracked (ردیابی نشده، نشان‌دهنده وضعیت فایل‌هایی است که هنوز به مخزن Git اضافه نشده‌اند)
* unmodified (تغییر نیافته، نشان‌دهنده وضعیتی است که فایلی برای اولین بار اضافه می‌شود، یا محتوای فایل با محتوای HEAD سازگار است)
* modified (تغییر یافته، نشان‌دهنده این است که فایل ویرایش شده است، یا محتوای فایل با محتوای HEAD ناسازگار است)
* staged (منتظر ثبت، نشان‌دهنده این است که تمام این فایل‌ها دفعه بعد که `git commit` اجرا شود به مخزن ارسال خواهند شد)

### git status

دریافت وضعیت **working tree** (دایرکتوری کاری).

از آنجایی که قبلاً در مورد رابطه بین مخزن (repository)، دایرکتوری کاری (working directory)، اشیاء (objects) و ایندکس (index) صحبت کرده‌ایم، می‌توانیم این رابطه را در یک جمله توضیح دهیم:

```txt
عملیات مخزن Git عبارت است از نوشتن داده‌ها در اشیاء Git با به‌روزرسانی ایندکس از طریق تغییرات در دایرکتوری کاری.
```

هدف از دستور `git status` در اینجا نمایش تفاوت بین **آخرین نسخه** و **فایل ایندکس** است. تفاوت‌های موجود در اینجا شامل برخی روابط ظریف است. بیایید از یک مثال برای توضیح این رابطه استفاده کنیم.

در زیر نتیجه اجرای `git status` آورده شده است:

```sh
G:\git-demo>git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       new file:   c.txt
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#       modified:   a.txt
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#       b.txt
```

در اینجا سه گروه مختلف را مشاهده خواهید کرد، یعنی:

* Changes to be committed (تغییرات آماده برای ثبت)
  * یک فایل `new file: c.txt` در این ناحیه وجود دارد، به این معنی که `c.txt` یک فایل جدید است و به عنوان آماده برای ثبت (commit) علامت‌گذاری شده است.
  * این نشان‌دهنده چندین مورد است:
    ۱. فایل `c.txt` در حال حاضر در **دایرکتوری کاری** (working directory) وجود دارد.
    ۲. فایل `c.txt` به **ایندکس** (index) اضافه شده است.
    ۳. محتوای `c.txt` در **ایندکس** با محتوای موجود در **دایرکتوری کاری** سازگار است.
    ۴. هنگام اجرای `git commit` محتوای موجود در **ایندکس** ثبت خواهد شد (نه محتوای دایرکتوری کاری).

* Changes not staged for commit (تغییراتی که اصلاح شده‌اند اما هنوز برای ثبت آماده نشده‌اند)
  * یک فایل `modified: a.txt` در این ناحیه وجود دارد، به این معنی که `a.txt` یک فایل تغییر یافته است اما به عنوان آماده برای ثبت علامت‌گذاری نشده است.
  * این نشان‌دهنده چندین مورد است:
    ۱. فایل `a.txt` در حال حاضر در **دایرکتوری کاری** وجود دارد.
    ۲. فایل `a.txt` به **ایندکس** اضافه شده است.
    ۳. محتوای `a.txt` در **ایندکس** با محتوای موجود در **دایرکتوری کاری** ناسازگار است.
    ۴. هنگام اجرای `git commit` فقط محتوای موجود در **ایندکس** ثبت خواهد شد (نه محتوای دایرکتوری کاری).

* Untracked files (فایل‌های ردیابی نشده)
  * یک فایل `b.txt` در این ناحیه وجود دارد، به این معنی که `b.txt` یک فایل جدید است و به ایندکس اضافه نشده است.
  * این نشان‌دهنده چندین مورد است:
    ۱. فایل `b.txt` در حال حاضر در **دایرکتوری کاری** وجود دارد.
    ۲. فایل `b.txt` به **ایندکس** اضافه نشده است.
    ۳. هنگام اجرای `git commit` این فایل ثبت نخواهد شد.

### git add

اضافه کردن محتوای فایل به ایندکس (آماده‌سازی فایل‌ها برای ثبتِ بعدی).

دستور `git add` کاربردهای زیادی دارد. به سادگی، اجرای این دستور "ایندکس را به‌روزرسانی می‌کند"، اما نحوه به‌روزرسانی ایندکس ممکن است بسته به وضعیت فعلی فایل متفاوت باشد:

* اگر فایل در حالت **untracked** باشد، اجرای `git add` محتوای فایل را به ایندکس اضافه می‌کند.
* اگر فایل در حالت **modified** باشد، اجرای `git add` محتوای فایل را در ایندکس به‌روزرسانی می‌کند.
* اگر فایل در حالت **staged** باشد، اجرای `git add` دوباره محتوای فایل را در ایندکس به‌روزرسانی می‌کند.

### git rm

حذف فایل‌ها از دایرکتوری کاری (working tree) و از ایندکس.

این دستور فایل‌ها را هم از **دایرکتوری کاری** و هم از **ایندکس** حذف می‌کند. پس از حذف، باید `git commit` را برای تکمیل این عمل حذف اجرا کنید.

### git mv

انتقال یا تغییر نام یک فایل، یک دایرکتوری یا یک لینک نمادین (symlink).

این دستور فایل‌ها را هم در **دایرکتوری کاری** و هم در **ایندکس** جابجا می‌کند یا نام آن‌ها را تغییر می‌دهد. پس از جابجایی یا تغییر نام، باید `git commit` را برای تکمیل این عمل اجرا کنید.

### git commit

ثبت تغییرات در مخزن (repository).

این دستور محتوای فعلی **ایندکس** را در **پایگاه داده اشیاء** می‌نویسد و یک شیء کامیت (commit object) تولید می‌کند.

### git ls-files

نمایش اطلاعات مربوط به فایل‌های موجود در ایندکس و دایرکتوری کاری.

این دستور می‌تواند لیست فایل‌ها و وضعیت آن‌ها را در ایندکس نمایش دهد. این دستور بسیار مفیدی است که می‌تواند به شما در درک وضعیت فعلی ایندکس کمک کند.

برخی پارامترهای رایج:

* `git ls-files -s` یا `git ls-files --stage` : نمایش لیست فایل‌ها و اطلاعات دقیق در ایندکس
* `git ls-files -c` یا `git ls-files --cached` : نمایش لیست فایل‌های کش شده
* `git ls-files -d` یا `git ls-files --deleted` : نمایش لیست فایل‌های حذف شده
* `git ls-files -m` یا `git ls-files --modified` : نمایش لیست فایل‌های تغییر یافته
* `git ls-files -o` یا `git ls-files --others` : نمایش لیست فایل‌های ردیابی نشده

## خلاصه امروز

"ایندکس" در Git یک مفهوم بسیار مهم است. از طریق ایندکس، Git می‌تواند بداند کدام فایل‌ها قرار است در نسخه کامیت بعدی ثبت شوند. از طریق دستورات مختلف، می‌توانیم وضعیت ایندکس را به‌روزرسانی کرده و کنترل کنیم که کدام فایل‌ها ثبت خواهند شد. درک ایندکس می‌تواند به شما در تسلط بهتر بر کنترل نسخه Git کمک کند.

## لینک‌های مرجع

* [Git Internals - Git Objects](https://git-scm.com/book/en/Git-Internals-Git-Objects)
* [Pro Git Book](https://progit.org/)

---

* [بازگشت به فهرست مطالب](README.md)
* [روز قبل: تجزیه ساختار داده Git - ساختار اشیاء (Object Structure)](06.md)
* [روز بعد: مفاهیم پایه و استفاده از شاخه‌ها (Branches)](08.md)

---
