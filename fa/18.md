# روز ۱۸: اصلاح تاریخچه نسخه‌های ثبت شده - بخش ۱ (reset و amend)

هنگام استفاده از گیت برای کنترل نسخه، از `git commit` برای ایجاد نسخه‌های زیادی استفاده می‌کنیم. از آنجایی که Git یک سیستم کنترل نسخه توزیع شده است، در مقایسه با سیستم‌های کنترل نسخه متمرکز مانند Subversion یا TFVC، گیت طراحی مجوز کمتری برای کنترل نسخه دارد. گیت مکانیزم‌های بیشتری را برای "اصلاح رکوردهای نسخه" فراهم می‌کند و به شما اجازه می‌دهد تا قبل از "اشتراک‌گذاری" نسخه‌ها با دیگران، موارد را از قبل سازماندهی کنید.

## اصول اولیه کنترل نسخه

هنگام انجام کنترل نسخه، خواه استفاده از Git، Subversion یا TFVC باشد، نگهداری رکوردهای نسخه خوب به ما کمک می‌کند تا تاریخچه به‌روزرسانی هر نسخه را (زمانی که نیاز به انجام این کار داریم) ردیابی کنیم. بر اساس تجربه شخصی من، ما به ندرت فرصت یا تمایلی برای ردیابی فرآیند توسعه نرم‌افزار در یک پروژه داریم. بسیاری از پروژه‌های ما هزاران رکورد نسخه انباشته کرده‌اند - چه کسی وقت دارد آن تاریخچه را بررسی کند؟

با این حال، در عمل، زمانی که باگ‌های نرم‌افزاری رخ می‌دهند، ما نیاز داریم سوابق تاریخی باگ‌های خاص را ردیابی کنیم تا علت واقعی باگ را پیدا کنیم. این زمانی است که کنترل نسخه بیشترین ارزش را به ارمغان می‌آورد.

بنابراین، نحوه نگهداری "رکوردهای نسخه" خوب نیز بسیار مهم است. در اینجا برخی از اصول کنترل برای به اشتراک گذاشتن آورده شده است:

* برای هر اصلاح کوچک در یک قابلیت، یک نسخه ایجاد کنید تا ردیابی تغییرات آسان‌تر شود.
* هرگز قبل از ایجاد یک "نسخه بزرگ"، تعداد زیادی اصلاحات را انباشته نکنید.
* قابلیت‌ها را به صورت منطقی و به ترتیب درست کنید و اطمینان حاصل کنید که اصلاحات مربوط به نسخه‌ها برای ردیابی آسان‌تر، به ترتیب Commit می‌شوند.

با این حال، انسان‌ها اشتباه می‌کنند - چه کسی می‌تواند تضمین کند که همه افراد تیم همیشه می‌توانند برای کنترل نسخه از اصول فوق پیروی کنند؟ چه کسی "فقط همانطور که فکر می‌کند تغییر نمی‌دهد"؟ چنین الزاماتی عملاً دشوار می‌شوند. بنابراین، ما به مکانیزمی برای "اصلاح نسخه‌ها" نیاز داریم تا وقتی نسخه‌ها به سرور راه دور ارسال می‌شوند، از قبل در وضعیت عالی باشند.

## دلایل اصلاح تاریخچه کامیت (Commit History)

تا اینجا به جزئیات "مخازن راه دور" (remote repositories) اشاره نکرده‌ایم، بنابراین بیشتر عملیات گیت هنوز بر عملیات محلی متمرکز است، یعنی کنترل نسخه در دایرکتوری کاری، با این مخزن که در پوشه `.git/` شما قرار دارد. با این حال، به زودی در مورد کاربرد "مخازن راه دور" بحث خواهیم کرد، زمانی که بیش از یک نفر مخزن داشته باشند و جزئیات بیشتری نیاز به توجه داشته باشند.

اجازه دادن به همه برای اصلاح خودسرانه تاریخچه کامیت ممکن است برای افرادی که با Subversion یا TFVC آشنا هستند عجیب به نظر برسد، زیرا قبلاً همه به صورت متمرکز به یک سرور کنترل نسخه متصل می‌شدند و از یک مخزن متمرکز استفاده می‌کردند. اگر کسی می‌توانست به طور خودسرانه سوابق تاریخی را دستکاری کند، آیا هنوز هم می‌توانست کنترل نسخه نامیده شود؟

در واقع در کنترل نسخه Git، مفهوم همان است. تا زمانی که یک مخزن توسط چندین نفر به اشتراک گذاشته شود، اگر کسی به طور خودسرانه نسخه‌ها را دستکاری کند، کنترل نسخه Git نیز به درستی کار نخواهد کرد.

بنابراین، چه سناریوهایی برای اصلاح رکوردهای نسخه مورد نیاز است؟ می‌توانید به نکات زیر مراجعه کنید.

با فرض اینکه اکنون سه نسخه داریم: [A] -> [B] -> [C]

* ممکن است متوجه شوید که نسخه [C] به اشتباه Commit شده است و باید تمام تغییرات در این نسخه را حذف کنید.
* ممکن است پس از Commit کردن [C] متوجه شوید که این نسخه فقط شامل کد تست است و می‌خواهید آن را حذف کنید.
* برخی از پیام‌های رکورد نسخه دارای اشتباهات تایپی هستند و می‌خواهید متن پیام را بدون تأثیر بر تاریخچه تغییرات فایل اصلاح کنید.
* ممکن است بخواهید ترتیب Commit این نسخه‌ها را به [A] -> [C] -> [B] تغییر دهید تا تکامل نسخه منطقی‌تر شود.
* متوجه می‌شوید که در نسخه [B] قبل از Commit کردن، فراموش کرده‌اید یک فایل مهم را درج کنید و می‌خواهید این تغییر را بعداً جبران کنید.
* وقتی قصد دارید یک شاخه را "به اشتراک بگذارید"، نقایص کد را کشف می‌کنید و می‌توانید آن‌ها را قبل از اشتراک‌گذاری برطرف کنید.

## نکات مهم برای اصلاح تاریخچه کامیت

گیت مکانیزم "اصلاح رکوردهای تاریخچه نسخه" را حفظ می‌کند، عمدتاً با این امید که پس از اینکه "نسخه‌های خود-مدیریتی" را تا حد معینی انجام دادید، بتوانید اطلاعات مختلف را در رکوردهای نسخه سازماندهی کنید، به طوری که پس از اینکه نسخه‌ها را "منتشر" کردید، دیگران بتوانند با وضوح بیشتری درک کنند که چه اصلاحاتی در این نسخه‌ها انجام داده‌اید.

بنابراین، هنگام اصلاح رکوردهای تاریخچه نسخه، باید به برخی موارد توجه ویژه داشت:

* یک مخزن می‌تواند شاخه‌های زیادی داشته باشد (نام شاخه پیش‌فرض `master` است).
* حداقل واحد برای اشتراک‌گذاری کد منبع گیت، "شاخه" (branch) است.
* شما می‌توانید نسخه‌ها را در یک شاخه به طور خودسرانه اصلاح کنید، تا زمانی که آن‌ها را با دیگران "به اشتراک نگذاشته‌اید".
* **به محض اینکه یک شاخه خاص را با دیگران "به اشتراک گذاشتید"، دیگر رکوردهای تاریخچه نسخه "به اشتراک گذاشته شده" را اصلاح نکنید!**

## درک git commit --amend

گزینه `--amend` به شما اجازه می‌دهد تا آخرین کامیت را اصلاح کنید. این مورد زمانی مفید است که:

* بخواهید پیام کامیت را تغییر دهید.
* فراموش کرده باشید برخی فایل‌ها را درج کنید.
* نیاز داشته باشید یک اشتباه کوچک در آخرین کامیت را برطرف کنید.

### تغییر آخرین پیام کامیت

```
git commit --amend -m "پیام جدید کامیت"
```

### اضافه کردن فایل‌ها به آخرین کامیت

```
# تغییرات را انجام دهید یا فایل‌های فراموش شده را اضافه کنید
git add forgotten-file.txt

# کامیت را اصلاح کنید
git commit --amend --no-edit
```

پرچم `--no-edit` پیام کامیت موجود را حفظ می‌کند.

### اصلاح تعاملی (Interactive Amend)

برای ویرایش پیام کامیت در ویرایشگر خود:

```
git commit --amend
```

این کار ویرایشگر پیکربندی شده شما را باز می‌کند که در آن می‌توانید پیام کامیت را تغییر دهید.

## درک git reset

`git reset` یک دستور قدرتمند است که می‌تواند:

* اشاره‌گر شاخه فعلی را حرکت دهد.
* ناحیه آماده‌سازی (staging area یا ایندکس) را اصلاح کند.
* دایرکتوری کاری را اصلاح کند.

سه حالت برای ریست وجود دارد:

۱. **--soft**: HEAD را حرکت می‌دهد، اما ناحیه آماده‌سازی و دایرکتوری کاری را بدون تغییر نگه می‌دارد.
۲. **--mixed** (پیش‌فرض): HEAD را حرکت می‌دهد، ناحیه آماده‌سازی را ریست می‌کند، اما دایرکتوری کاری را بدون تغییر نگه می‌دارد.
۳. **--hard**: HEAD را حرکت می‌دهد، ناحیه آماده‌سازی و دایرکتوری کاری را ریست می‌کند.

## ریست نرم (Soft Reset)

اشاره‌گر شاخه را حرکت می‌دهد اما تغییرات شما را در حالت آماده‌سازی (staged) نگه می‌دارد:

```
git reset --soft HEAD~1
```

این کار آخرین کامیت را لغو می‌کند اما تغییرات شما را در ناحیه آماده‌سازی باقی می‌گذارد تا دوباره Commit شوند.

## ریست ترکیبی (Mixed Reset)

اشاره‌گر شاخه را حرکت می‌دهد و تغییرات را از حالت آماده‌سازی خارج می‌کند:

```
git reset HEAD~1
# یا
git reset --mixed HEAD~1
```

این کار آخرین کامیت را لغو کرده و تغییرات را از حالت آماده‌سازی خارج می‌کند، اما تغییرات در دایرکتوری کاری شما باقی می‌مانند.

## ریست سخت (Hard Reset)

کاملاً کامیت و تمام تغییرات را حذف می‌کند:

```
git reset --hard HEAD~1
```

**هشدار**: این کار تغییرات را برای همیشه حذف می‌کند. با احتیاط استفاده کنید!

## ریست کردن به یک کامیت خاص

شما می‌توانید به هر کامیتی ریست کنید:

```
# با استفاده از هش کامیت
git reset --hard a1b2c3d

# با استفاده از مرجع نسبی
git reset --soft HEAD~3
```

## خارج کردن فایل‌ها از حالت آماده‌سازی (Unstaging Files)

برای خارج کردن یک فایل از حالت آماده‌سازی بدون از دست دادن تغییرات:

```
git reset HEAD file.txt
# یا
git restore --staged file.txt
```

## بازیابی پس از ریست (Recovering from Reset)

اگر به اشتباه ریست کردید، معمولاً می‌توانید با استفاده از reflog آن را بازیابی کنید:

```
git reflog
git reset --hard HEAD@{2}
```

## تفاوت ریست (Reset) در مقابل بازگرداندن (Revert)

تمایز مهم:

* **reset**: تاریخچه را بازنویسی می‌کند (برای کامیت‌های محلی و Push نشده استفاده کنید).
* **revert**: یک کامیت جدید ایجاد می‌کند که تغییرات را لغو می‌کند (برای تاریخچه مشترک ایمن است).

## موارد استفاده رایج

### لغو آخرین کامیت، نگه داشتن تغییرات

```
git reset HEAD~1
```

### لغو آخرین کامیت، حذف تغییرات

```
git reset --hard HEAD~1
```

### تقسیم یک کامیت به چندین کامیت

```
git reset HEAD~1
git add file1.txt
git commit -m "بخش اول"
git add file2.txt
git commit -m "بخش دوم"
```

### تغییر چند کامیت آخر

```
git reset --soft HEAD~3
# تغییرات را انجام دهید
git commit -m "کامیت ترکیبی"
```

## هشدارها و بهترین تجربه‌ها

۱. **هرگز تاریخچه عمومی را ریست نکنید**: کامیت‌هایی را که به مخازن مشترک Push شده‌اند ریست نکنید.
۲. **از --amend با دقت استفاده کنید**: فقط کامیت‌هایی را که Push نشده‌اند اصلاح کنید.
۳. **گزینه‌های جایگزین را در نظر بگیرید**: برای تاریخچه مشترک، به جای آن از `git revert` استفاده کنید.
۴. **دوبار چک کنید**: به خصوص قبل از استفاده از `--hard`.
۵. **reflog خود را بشناسید**: این ابزار می‌تواند شما را از اشتباهات نجات دهد.

## خلاصه امروز

`git commit --amend` و `git reset` ابزارهای قدرتمندی برای اصلاح تاریخچه کامیت محلی هستند. `--amend` برای اصلاحات سریع در آخرین کامیت عالی است، در حالی که `reset` کنترل بیشتری روی چندین کامیت به شما می‌دهد. با این حال، هر دو باید با دقت استفاده شوند، به ویژه برای کامیت‌هایی که با دیگران به اشتراک گذاشته شده‌اند.

اجازه دهید دستورات گیت و پارامترهای یاد گرفته شده امروز را دوباره سازماندهی کنم:

* git commit --amend
* git commit --amend --no-edit
* git reset --soft
* git reset --mixed
* git reset --hard
* git reset HEAD~n
* git reflog

---

* [بازگشت به فهرست مطالب](README.md)
* [روز قبل: مفاهیم پایه و استفاده از ادغام (Merging)](17.md)
* [روز بعد: تنظیم لیست نادیده گرفتن .gitignore](19.md)

---
