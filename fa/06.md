# روز ۰۶: تجزیه ساختار داده Git - ساختار اشیاء (Object Structure)

در ساختار داده‌های Git، "اشیاء" (objects) از نوع فایل‌های "تغییرناپذیر" (immutable) هستند. تمام فایل‌های ذخیره شده در "ذخیره‌سازی اشیاء" (object storage) معمولاً فقط وارد می‌شوند و خارج نمی‌شوند و محتوای آن‌ها تغییر نخواهد کرد. دلیل پیش‌فرض این است که اگر محتوای فایل را دستکاری کنید، مقدار هش SHA1 محاسبه شده از محتوای جدید با نام فایلِ شیء اصلی متفاوت خواهد بود که باعث می‌شود Git نتواند به اجرای خود ادامه دهد و نسبتاً هم درجه خاصی از محافظت را برای مخزن Git فراهم می‌کند. این مقاله ساختار اشیاء Git را با جزئیات بیشتر معرفی می‌کند و در نهایت فرآیند و منطق نحوه تولید اشیاء را از طریق یک ویدیو به طور مفصل توضیح می‌دهد.

## درباره پایگاه داده اشیاء (Object Database)

همانطور که در مقاله قبلی ذکر شد، خواه اشیاء blob باشند یا اشیاء درختی (tree objects)، این‌ها همگی اشیاء هستند و این اشیاء در یک به اصطلاح "ذخیره‌سازی اشیاء" (object storage) ذخیره می‌شوند که به طور پیش‌فرض در دایرکتوری `objects` از "مخزن" (repository) قرار دارد، همانطور که در شکل زیر نشان داده شده است:

![image](figures/06/01.png)

با این حال، هر "شیء" در مخزن Git یک عملیات هش SHA1 روی "محتوای فایل" انجام می‌دهد تا یک مقدار هش محاسبه کند و از این مقدار هش به عنوان نام شیء (نام فایل) استفاده می‌کند. به عنوان مثال `8a6b275638f3cf164395e65066a1132bb36b7896` را در نظر بگیرید؛ Git ابتدا دو کاراکتر اول (8a) را به عنوان دایرکتوری در نظر می‌گیرد و سپس از باقی‌مانده مقدار هش به عنوان نام فایل استفاده می‌کند (`6b275638f3cf164395e65066a1132bb36b7896`). دایرکتوری فیزیکی و فایل‌های این اشیاء نیز در دایرکتوری `.git\objects` قرار خواهند گرفت، همانطور که در شکل زیر نشان داده شده است:

![image](figures/06/02.png)

## انواع اشیاء (Object Types)

در این "پایگاه داده اشیاء"، ۴ نوع شیء وجود دارد:

۱. **blob object**: این "محتوای" یک فایل در دایرکتوری کاری است، و فقط محتوا. وقتی دستور `git add` را اجرا می‌کنید، محتوای این فایل‌های جدید بلافاصله به عنوان اشیاء blob نوشته می‌شود. نام فایل نتیجه هشِ محتوای شیء است، بدون هیچ اطلاعات دیگری. اطلاعاتی مانند زمان فایل، نام اصلی فایل یا سایر اطلاعات فایل در انواع دیگر اشیاء (یعنی اشیاء درختی) ذخیره خواهند شد.

۲. **tree object**: این نوع شیء تمام اطلاعات تحت یک دایرکتوری خاص را ذخیره می‌کند، از جمله نام فایل‌های تحت آن دایرکتوری، نام‌های اشیاء blob مربوطه، لینک‌های نمادین (symbolic links) یا سایر اشیاء درختی. از آنجایی که اشیاء درختی می‌توانند حاوی اشیاء درختی دیگر باشند، گشت و گذار در اشیاء درختی در واقع همانند "پوشه‌ها" در سیستم فایل است. به سادگی، اشیاء درختی اسنپ‌شات‌هایی (snapshots) از یک پوشه تحت یک نسخه خاص هستند.

۳. **commit object**: برای ثبت اینکه کدام اشیاء درختی در نسخه گنجانده شده‌اند استفاده می‌شود. یک شیء کامیت نشان‌دهنده یک Git commit است که ثبت می‌کند کدام اشیاء درختی در یک نسخه کامیت خاص هستند، و همچنین زمان ثبت نسخه، پیام کامیت (commit message) و غیره. معمولاً نام شیء کامیت قبلی را نیز ثبت می‌کند (فقط اولین نسخه کامیت نام شیء کامیت قبلی ندارد).

۴. **tag object**: این یک ظرف (container) است که معمولاً برای ارتباط با یک شیء کامیت خاص استفاده می‌شود (همچنین می‌تواند با اشیاء blob و درختی خاص مرتبط باشد) و برخی اطلاعات مرجع اضافی (metadata) مانند نام تگ را ذخیره می‌کند. رایج‌ترین کاربرد اشیاء تگ، علامت‌گذاری یک نسخه خاص از یک شیء کامیت با نامی قابل فهم است که ممکن است نشان‌دهنده یک نسخه انتشار خاص یا یک نسخه با اهمیت ویژه باشد.

گیت برای هر فایل در هر نسخه، یک شیء blob مربوطه ایجاد می‌کند. به همین ترتیب، نام فایل شیء blob به روش فوق محاسبه می‌شود. از این فایل‌های blob، شما نمی‌توانید هیچ رابطه‌ای با نسخه را ببینید. شما باید از اشیاء درختی (اسنپ‌شات‌های پوشه‌ها) و اشیاء کامیت (اسنپ‌شات‌های هر نسخه) برای مرتبط کردن رابطه بین این blobها و نسخه‌ها استفاده کنید.

تمام اشیاء با استفاده از الگوریتم zlib فشرده می‌شوند که نه تنها می‌تواند به طور مؤثری کارایی دسترسی به فایل را بهبود بخشد، بلکه از الگوریتم فشرده‌سازی delta (تفاضلی) برای صرفه‌جویی در فضا هنگام بسته‌بندی (packing) در آینده استفاده می‌کند. گیت به طور خودکار blobهای مشابه را پیدا می‌کند، تفاوت‌های بین آن‌ها را محاسبه می‌کند و این تفاوت‌ها را در فایلی به نام *packfile* ذخیره می‌کند که می‌تواند به شدت فضای دیسک را ذخیره کند. معمولاً *packfiles* در دایرکتوری `.git\objects\pack` قرار می‌گیرند، همانطور که در شکل زیر نشان داده شده است:

![image](figures/06/03.png)

رابطه بین این چهار نوع شیء را می‌توان در نمودار زیر مشاهده کرد:

![image](figures/06/04.png)

با این حال، فقط نگاه کردن به متن و نمودارها ممکن است هنوز برای دیدن رابطه بین این انواع اشیاء دشوار باشد. اشکالی ندارد؛ من به طور ویژه یک ویدیوی آموزشی ضبط کرده‌ام تا سعی کنم ساختار اشیاء Git و فرآیند تولید اشیاء با استفاده از دستورات git را توضیح دهم، تا همه بتوانند واضح‌تر درک کنند که Git چگونه این فایل‌ها را تولید و مدیریت می‌کند.

لینک ویدیو در یوتیوب: [درک رابطه بین پایگاه داده اشیاء (Object Database) و اشیاء در ساختار داده Git](https://www.youtube.com/watch?v=PZbSRy_ow0U)

## مزایای ساختار اشیاء

شما باید به تدریج درک کنید که طراحی "شیء" گیت چقدر زیباست. در اولین مقاله، چندین طراحی مهم Git را ذکر کردیم. بیایید چند طراحی مرتبط با ویژگی‌های "شیء" را دوباره لیست کنیم:

* مدیریت کارآمد پروژه‌های بزرگ
* نه تنها یک مخزن کامل در دستگاه محلی Clone می‌شود، بلکه چون تمام اشیاء blob از طریق "محتوا" قابل آدرس‌دهی هستند، پیدا کردن محتوای یکسان بین نسخه‌های مختلف بسیار کارآمد است.
* محافظت از سوابق تاریخی
* در فرآیند کنترل نسخه Git، هر Commit یک شیء کامیت تولید می‌کند و نام این شیء از طریق محتوای آن تولید می‌شود. علاوه بر این، شیء کامیت با اشیاء درختی مرتبط است و نام شیء درختی از طریق محتوای آن تولید می‌شود. اشیاء درختی با اشیاء blob و درختی مرتبط هستند و نام این اشیاء نیز از طریق محتوا تولید می‌شود. ارتباط لایه به لایه به این صورت، اگر واقعاً بخواهید تاریخچه یک نسخه خاص را امروز دستکاری کنید، سختی کار بسیار بالاست!
* از آنجایی که مخازن Git اغلب Clone یا Fork می‌شوند، تا زمانی که یک مخزن Clone شده باشد، اگر هر شیئی در مخزن اصلی تغییر کند، ادغام مجدد این مخازن Clone شده دشوار خواهد بود، بنابراین به سختی می‌توانید سوابق نسخه را به طور خودسرانه دستکاری کنید.
* بسته‌بندی منظم اشیاء (Regular packing of objects)
* "اشیایی" (objects) که در Git نام می‌بریم در واقع نشان‌دهنده فایل‌ها در مخزن هستند. در فرآیند تغییرات نسخه، کد یا سایر فایل‌های پروژه به‌روزرسانی می‌شوند. هر بار که به‌روزرسانی می‌شود، تا زمانی که محتوای فایل متفاوت باشد، یک "شیء" جدید ایجاد می‌شود و تمام این فایل‌ها با محتوای متفاوت حفظ می‌شوند.
* می‌توانید تصور کنید که با بزرگتر شدن یک پروژه و داشتن نسخه‌های بیشتر، اشیاء بیشتر و بیشتری وجود خواهد داشت. اگرچه هر فایل را می‌توان به صورت جداگانه فشرده کرد تا فایل کوچکتر شود، اما تعداد زیاد فایل‌ها باعث می‌شود دسترسی به فایل‌ها کمتر و کمتر کارآمد باشد. بنابراین، طراحی Git دارای مکانیزمی است که می‌تواند به طور خودکار مجموعه‌ای از "اشیاء" قدیمی را در یک packfile بسته‌بندی کند تا کارایی دسترسی به فایل بهبود یابد.
* آن فایل‌های جدیداً اضافه شده همچنان به عنوان فایل‌های تکی وجود خواهند داشت، که به این معنی است که یک "فایل" در یک مخزن Git یک "شیء" Git است، اما باید هر از چند گاهی دوباره بسته‌بندی شود.
* احتمالاً گیت به طور خودکار کارهایی مانند بررسی و بسته‌بندی مجدد را انجام می‌دهد، اما همچنان می‌توانید خودتان دستوراتی برای اجرای آن‌ها صادر کنید. به عنوان مثال: `git gc`
* اگر می‌خواهید بررسی کنید که آیا سیستم فایل نگهداری شده توسط Git کامل است، می‌توانید دستور زیر را اجرا کنید: `git fsck`

## خلاصه امروز

"اشیاء" در Git بسیار مهم هستند و ویژگی‌های آن‌ها نیز بسیار اهمیت دارد. اگرچه ما معمولاً نیازی به لمس مستقیم این فایل‌ها در طول فرآیند اجرای دستورات Git نداریم، اما درک وجود این اشیاء به شما کمک می‌کند تا حالت عملیاتی Git و مفاهیم طراحی منحصر به فرد آن را بهتر درک کنید.

## لینک‌های مرجع

* [Git Internals - Git Objects](https://git-scm.com/book/en/Git-Internals-Git-Objects)
* [Pro Git Book](https://progit.org/)
* [Git Magic - Traditional Chinese Version](https://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_tw/)
* [Git (software) - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Git_(software) "Git (software) - Wikipedia, the free encyclopedia")

---

* [بازگشت به فهرست مطالب](README.md)
* [روز قبل: درک رابطه بین مخزن (Repository)، دایرکتوری کاری (Working Directory)، اشیاء (Objects) و ایندکس (Index)](05.md)
* [روز بعد: تجزیه ساختار داده Git - ساختار ایندکس (Index Structure)](07.md)

---
