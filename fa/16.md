# روز ۱۶: استفاده از git reflog برای ردیابی تاریخچه تغییرات

یادگیری دستورات کنترل نسخه Git دشوار نیست، اما درک اینکه Git واقعاً با مخزن شما چه می‌کند می‌تواند چالش‌برانگیز باشد. با درک تدریجی مفاهیم اصلی و اصول عملیاتی Git، می‌توانید به طور مؤثری تغییرات نسخه را در مخزن خود کنترل کنید. این مقاله توضیح می‌دهد که Git چگونه تاریخچه تغییرات را برای هر نسخه ثبت می‌کند.

## درک git reflog

`git reflog` (سوابق مرجع - reference log) مکانیزمی است که زمان به‌روزرسانی نوکِ شاخه‌ها و سایر مراجع در مخزن محلی را ثبت می‌کند. قبل از اینکه اصول اولیه و ساختار اشیاء Git را کاملاً درک کنید، نمی‌توانید فرآیند ثبت نسخه را به درستی بفهمید. وقتی فرآیند ثبت نسخه را درک نمی‌کنید، طبیعتاً نگران می‌شوید که "نسخه من کجا رفت؟" ممکن است شنیده باشید که کسی می‌گوید "ما از کنترل نسخه استفاده می‌کنیم، پس تمام نسخه‌ها حفظ می‌شوند، با خیال راحت کد را تغییر دهید." دانستن این یک چیز است، دانستن نحوه انجام آن چیز دیگری است و اینکه آیا واقعاً می‌توانید آن را انجام دهید، موضوع دیگری است.

خوشبختانه، Git دارای یک مکانیزم ثبت دقیق (logging) است و این مکانیزم بسیار باز است - فایل‌های گزارش همگی در قالب متنی هستند و به راحتی قابل درک می‌باشند. بیایید این فرآیند ثبت نسخه را توضیح دهیم.

reflog به ویژه برای موارد زیر مفید است:

* یافتن کامیت‌هایی که دیگر از هیچ شاخه‌ای قابل دستیابی نیستند
* بازیابی پس از `reset` یا `rebase` اشتباه
* درک کارهایی که در مخزن خود انجام داده‌اید
* لغو تغییرات تصادفی

## دایرکتوری logs

اگر وارد هر دایرکتوری کاری Git و پوشه `.git/` شوید، یک دایرکتوری `logs` را می‌بینید. این پوشه شامل یک فایل `HEAD` است که تاریخچه تغییرات نسخه "شاخه فعلی" را ثبت می‌کند.

محتوای فایل چیزی شبیه به این است (idهای اشیاء برای خوانایی کوتاه شده‌اند):

```
0000000 f5685e0 Will <xxxx@gmail.com> 1381718394 +0800	commit (initial): Initial commit
f5685e0 38d924f Will <xxxx@gmail.com> 1381718395 +0800	commit: a.txt: set 1 as content
38d924f efa1e0c Will <xxxx@gmail.com> 1381734238 +0800	commit: test
efa1e0c af493e5 Will <xxxx@gmail.com> 1381837967 +0800	commit: Add c.txt
```

## استفاده پایه

برای مشاهده reflog:

```
git reflog
```

این دستور لیستی از اقدامات اخیر را به ترتیب زمانی معکوس نشان می‌دهد. در فایل متنی، می‌توانید "اولین نسخه" را در بالا ببینید، اما از طریق `git reflog` "آخرین نسخه" ابتدا نمایش داده می‌شود و "اولین نسخه" در انتها.

هر ورودی نشان می‌دهد:
* هش کامیت (commit hash)
* مرجع (معمولاً HEAD)
* اقدامی که انجام شده است
* پیام کامیت

## فرمت Reflog

خروجی شبیه به این است:

```
a1b2c3d HEAD@{0}: commit: Add new feature
e4f5g6h HEAD@{1}: checkout: moving from master to feature-branch
i7j8k9l HEAD@{2}: reset: moving to HEAD~1
```

نمادگذاری `HEAD@{n}` به n-امین مقدار قبلیِ HEAD اشاره دارد. در اینجا، هر نسخه در گزارش تاریخچه دارای عددی است که نشان‌دهنده موقعیت این نسخه در فایل گزارش است. `HEAD@{0}` همیشه نشان‌دهنده "آخرین نسخه" شاخه فعلی است، به عبارت دیگر، آخرین عملیات Git که روی این "شاخه" انجام داده‌اید. هرگونه تغییر نسخه که در Git ایجاد کنید، به طور کامل ثبت خواهد شد.

## بازیابی از تغییرات تصادفی

زمانی که مبتدیان برای اولین بار از Git استفاده می‌کنند، ممکن است به طور تصادفی دستورات نادرستی را اجرا کنند، مانند تداخل‌هایی که در حین `git merge` رخ می‌دهد، یا اشتباهاتی که هنگام اجرای `git pull` برای دریافت آخرین نسخه از مخزن راه دور اتفاق می‌افتد. در چنین مواقعی، می‌توانید از "نام مرجع" خاصِ `HEAD@{n}` برای "مکان‌یابی" این نسخه استفاده کنید و نسخه فعلی مخزن Git را به نسخه قبلی بازگردانید.

به عنوان مثال، اگر بخواهیم آخرین رکورد نسخه را "لغو" کنیم، می‌توانیم از `git reset HEAD@{1} --hard` برای بازیابی تغییر استفاده کنیم. این به این معنی است که تغییری که در ابتدا در `HEAD@{0}` بود حذف خواهد شد. با این حال، در Git تمام تغییرات ثبت می‌شوند، از جمله عملِ اجرای `git reset "HEAD@{1}" --hard` توسط شما.

این به چه معناست؟ یعنی هنگام اجرای هر دستور Git، دیگر نیازی نیست نگران باشید که داده‌های شما از دست برود. مهم نیست چقدر دستور اشتباهی وارد کنید، تمام فایل‌هایی که از قبل در مخزن هستند حفظ خواهند شد و مطلقاً هیچ شانسی برای از دست رفتن ندارند. بنابراین، اگر می‌خواهید عمل `git reset "HEAD@{1}" --hard` که همین الان اجرا کردید را لغو کنید، فقط دوباره `git reset "HEAD@{1}" --hard` را اجرا کنید. عالی نیست!

## مشاهده Reflog دقیق

برای اطلاعات دقیق‌تر:

```
git reflog show --all
```

برای مشاهده reflog یک شاخه خاص:

```
git reflog show branch-name
```

## استفاده از Reflog برای بازیابی کامیت‌ها

اگر به طور تصادفی کامیت‌ها را ریست کرده یا گم کرده‌اید، می‌توانید با استفاده از reflog آن‌ها را بازیابی کنید:

```
# کامیتی که می‌خواهید بازیابی کنید را پیدا کنید
git reflog

# به آن کامیت ریست کنید
git reset --hard HEAD@{2}
```

یا مستقیماً از هش کامیت استفاده کنید:

```
git reset --hard a1b2c3d
```

## بازیابی شاخه‌های حذف شده

اگر شاخه‌ای را به اشتباه حذف کردید:

```
# کامیتی که در آن شاخه حذف شده است را پیدا کنید
git reflog

# شاخه را دوباره ایجاد کنید
git branch branch-name HEAD@{3}
# یا
git branch branch-name <commit-hash>
```

## انقضای Reflog

به طور پیش‌فرض، ورودی‌های reflog پس از ۹۰ روز برای کامیت‌های قابل دستیابی (reachable) و ۳۰ روز برای کامیت‌های غیرقابل دستیابی منقضی می‌شوند. می‌توانید این مورد را پیکربندی کنید:

```
git config gc.reflogExpire "90 days"
git config gc.reflogExpireUnreachable "30 days"
```

## پاکسازی Reflog

برای پاکسازی دستی ورودی‌های reflog:

```
# حذف ورودی‌های قدیمی reflog
git reflog expire --expire=now --all

# اجرای جمع‌آوری زباله (garbage collection)
git gc --prune=now
```

## محدودیت‌های Reflog

نکات مهمی که باید به خاطر بسپارید:

* reflog فقط محلی است - با دیگران به اشتراک گذاشته نمی‌شود
* reflog تغییرات مخزن شما را ردیابی می‌کند، نه فایل‌ها را
* می‌تواند به شما در بازیابی کامیت‌ها کمک کند، اما نه تغییرات Commit نشده

## مثال‌های کاربردی

### مثال ۱: لغو یک Hard Reset

```
# شما به طور تصادفی ریست کردید
git reset --hard HEAD~3

# موقعیت قبلی را پیدا کنید
git reflog

# به موقعیت قبلی بازگردانید
git reset --hard HEAD@{1}
```

### مثال ۲: بازیابی پس از یک Rebase اشتباه

```
# پس از یک rebase مشکل‌ساز
git reflog

# کامیت قبل از rebase را پیدا کنید (معمولاً با برچسب "rebase finished" مشخص می‌شود)
git reset --hard HEAD@{5}
```

## خلاصه امروز

`git reflog` یک ویژگی ایمنی قدرتمند است که می‌تواند شما را از بسیاری از اشتباهات گیت نجات دهد. به ویژه زمانی ارزشمند است که نیاز به بازیابی از عملیاتی مانند reset، rebase یا حذف شاخه دارید. اگرچه جایگزینی برای پشتیبان‌گیری منظم نیست، اما ابزاری گرانبها برای بازیابی محلی است.

اجازه دهید دستورات گیت و پارامترهای یاد گرفته شده امروز را دوباره سازماندهی کنم:

* git reflog
* git reflog show
* git reflog show --all
* git reset --hard HEAD@{n}
* git branch branch-name HEAD@{n}
* git reflog expire
* git gc

---

* [بازگشت به فهرست مطالب](README.md)
* [روز قبل: تگ‌ها - علامت‌گذاری رویدادهای مهم در کنترل نسخه](15.md)
* [روز بعد: مفاهیم پایه و استفاده از ادغام (Merge)](17.md)

---
