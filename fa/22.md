# روز ۲۲: اصلاح تاریخچه نسخه‌های ثبت شده - بخش ۴ (rebase)

ما قبلاً سه روش مختلف را برای اصلاح نسخه‌ها بحث کرده‌ایم. دقیقاً بخواهیم بگوییم، `git revert` و `git cherry-pick` واقعاً "رکوردهای تاریخچه نسخه را اصلاح نمی‌کنند" - آن‌ها نسخه‌هایی را که قبلاً Commit شده‌اند، خواه "اعمال مجدد" یا "اعمال معکوس" باشند، اعمال می‌کنند. این مقاله مکانیزم Rebase گیت را توضیح می‌دهد که واقعاً برای اصلاح رکوردهای کامیت استفاده می‌شود. این ویژگی مهم و قدرتمند است.

## درک git rebase

Rebase یکی از قدرتمندترین اما به طور بالقوه خطرناک‌ترین ویژگی‌های Git است. این دستور به شما اجازه می‌دهد تا تاریخچه کامیت را بازنویسی کنید تا تمیزتر و خطی‌تر شود.

Rebasing فرآیند جابجایی یا ترکیب دنباله‌ای از کامیت‌ها روی یک کامیت پایه‌ی جدید است. برخلاف ادغام (merging) که تاریخچه کامل را حفظ می‌کند، rebasing تاریخچه را بازنویسی می‌کند تا یک پیشرفت خطی ایجاد کند.

## استفاده پایه از Rebase

عملیات ری‌بیس پایه:

```
# در شاخه قابلیت (feature branch)
git checkout feature-branch

# ری‌بیس روی شاخه اصلی (main)
git rebase main
```

این کار تمام کامیت‌های `feature-branch` را روی `main` بازپخش (replay) می‌کند.

## نحوه عملکرد Rebase

وقتی ری‌بیس می‌کنید:

۱. گیت جدِ مشترک شاخه شما و شاخه هدف را پیدا می‌کند.
۲. تمام کامیت‌های شاخه شما از آن جدِ مشترک به بعد را ذخیره می‌کند.
۳. شاخه شما را به شاخه هدف ریست (reset) می‌کند.
۴. کامیت‌های ذخیره شده شما را یکی یکی دوباره اعمال می‌کند.

## Rebase در مقابل Merge

**Merge**:
* تاریخچه کامل را حفظ می‌کند.
* نشان می‌دهد که شاخه‌ها چه زمانی از هم جدا و چه زمانی ادغام شده‌اند.
* برای شاخه‌های مشترک ایمن است.
* کامیت‌های ادغام (merge commits) ایجاد می‌کند.

**Rebase**:
* تاریخچه خطی ایجاد می‌کند.
* تمیزتر و درک آن آسان‌تر است.
* تاریخچه را بازنویسی می‌کند (برای شاخه‌های مشترک خطرناک است).
* کامیت ادغام ایجاد نمی‌کند.

مقایسه بصری:

```
# قبل از rebase
      C---D feature
     /
A---B---E---F main

# بعد از git rebase main (در شاخه feature)
               C'---D' feature
              /
A---B---E---F main

# بعد از git merge feature (در شاخه main)
      C---D 
     /     A---B---E---F---G main
```

## مدیریت تداخل‌ها در حین Rebase

اگر تداخلی رخ دهد:

```
# گیت ری‌بیس را متوقف می‌کند
# تداخل‌ها را در فایل‌ها حل کنید
# فایل‌های حل شده را آماده (stage) کنید
git add <resolved-files>

# فرآیند ری‌بیس را ادامه دهید
git rebase --continue
```

برای لغو ری‌بیس:

```
git rebase --abort
```

برای نادیده گرفتن کامیت فعلی:

```
git rebase --skip
```

## ری‌بیس تعاملی (Interactive Rebase)

ری‌بیس تعاملی به شما کنترل کامل روی کامیت‌ها می‌دهد:

```
git rebase -i HEAD~3
```

این دستور ویرایشگری را باز می‌کند که در آن می‌توانید:

* **pick**: کامیت را همانطور که هست نگه دار.
* **reword**: پیام کامیت را تغییر بده.
* **edit**: برای اصلاح (amend) کامیت متوقف شو.
* **squash**: با کامیت قبلی ترکیب کن، هر دو پیام را نگه دار.
* **fixup**: با کامیت قبلی ترکیب کن، این پیام را نادیده بگیر.
* **drop**: کامیت را به طور کامل حذف کن.

مثالی از ویرایشگر ری‌بیس تعاملی:

```
pick abc123 Add feature A
reword def456 Add feature B
squash ghi789 Fix typo in feature B
drop jkl012 Experimental change
```

## وظایف رایج در ری‌بیس تعاملی

### فشرده‌سازی کامیت‌ها (Squashing Commits)

ترکیب چندین کامیت در یکی:

```
git rebase -i HEAD~3

# در ویرایشگر تغییر دهید:
pick abc123 First commit
pick def456 Second commit
pick ghi789 Third commit

# به:
pick abc123 First commit
squash def456 Second commit
squash ghi789 Third commit
```

### تغییر ترتیب کامیت‌ها

به سادگی خطوط را در ویرایشگر ری‌بیس تعاملی جابجا کنید.

### ویرایش یک کامیت

```
git rebase -i HEAD~3

# کلمه "pick" را به "edit" برای کامیتی که می‌خواهید تغییر دهید عوض کنید
# گیت در آن کامیت متوقف می‌شود
# تغییرات خود را انجام دهید
git add .
git commit --amend
git rebase --continue
```

## ری‌بیس کردن روی یک شاخه دیگر (Rebase onto)

```
git rebase --onto new-base old-base feature-branch
```

این دستور کامیت‌های `feature-branch` را که بعد از `old-base` آمده‌اند، به `new-base` منتقل می‌کند.

## Autosquash

فشرده‌سازی خودکار کامیت‌های fixup:

```
# ایجاد یک کامیت fixup
git commit --fixup <commit-to-fix>

# بعداً، ری‌بیس با autosquash
git rebase -i --autosquash main
```

## قانون طلایی ری‌بیس (Golden Rule of Rebasing)

**هرگز کامیت‌هایی را که به یک مخزن مشترک Push شده‌اند، ری‌بیس نکنید!**

ری‌بیس کردن تاریخچه را بازنویسی می‌کند، که می‌تواند باعث ایجاد مشکلات بزرگی برای دیگرانی شود که کار خود را بر اساس آن کامیت‌ها بنا کرده‌اند.

ایمن برای:
* کامیت‌های محلی که هنوز Push نشده‌اند.
* شاخه‌های قابلیتی (feature branches) که متعلق به خودتان است.
* تمیز کردن کدهای خود قبل از ایجاد یک Pull Request.

خطرناک برای:
* شاخه اصلی (main/master).
* شاخه‌های قابلیت مشترک.
* هر کامیتی که دیگران ممکن است کار خود را از آنجا شروع کرده باشند.

## بازیابی از اشتباهات ری‌بیس

اگر فرآیند ری‌بیس اشتباه پیش رفت:

```
# وضعیت قبل از ری‌بیس را پیدا کنید
git reflog

# به آن کامیت ریست کنید
git reset --hard HEAD@{2}
```

## بهترین تجربه‌ها (Best Practices)

۱. **قبل از Push ری‌بیس کنید**: کامیت‌های محلی خود را قبل از اشتراک‌گذاری تمیز کنید.
۲. **تاریخچه عمومی را ری‌بیس نکنید**: فقط کامیت‌های محلی را ری‌بیس کنید.
۳. **قبل از ری‌بیس بزرگ، بکاپ بگیرید**: ابتدا یک شاخه موقت بسازید.
۴. **ارتباط برقرار کنید**: اگر مجبورید کد مشترک را ری‌بیس کنید، به تیم خود اطلاع دهید.
۵. **تمرین کنید**: ری‌بیس کردن را ابتدا روی شاخه‌های آزمایشی امتحان کنید.

## خلاصه امروز

ری‌بیس یک ابزار قدرتمند برای ایجاد تاریخچه کامیت تمیز و خطی است. در حالی که برای کارهای محلی و آماده‌سازی شاخه‌ها برای ادغام عالی است، باید با دقت استفاده شود تا از بازنویسی تاریخچه مشترک جلوگیری شود. درک زمان و نحوه استفاده از rebase برای گردش‌های کاری پیشرفته Git ضروری است.

اجازه دهید دستورات گیت و پارامترهای یاد گرفته شده امروز را دوباره سازماندهی کنم:

* git rebase
* git rebase main
* git rebase -i
* git rebase --continue
* git rebase --abort
* git rebase --skip
* git rebase --onto
* git rebase --autosquash
* git commit --fixup

---

* [بازگشت به فهرست مطالب](README.md)
* [روز قبل: اصلاح تاریخچه نسخه‌های ثبت شده - بخش ۳ (cherry-pick)](21.md)
* [روز بعد: اصلاح تاریخچه نسخه‌های ثبت شده - بخش ۵ (rebase 2)](23.md)

---
