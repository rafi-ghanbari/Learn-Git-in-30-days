# روز ۲۱: اصلاح تاریخچه نسخه‌های ثبت شده - بخش ۳ (cherry-pick)

در فرآیند کنترل نسخه، موقعیت رایج دیگری وجود دارد: شما مدتی است که در یک شاخه در حال توسعه هستید، اما بعداً تصمیم می‌گیرید که دیگر کل آن شاخه را نمی‌خواهید. با این حال، چند کامیت در آن وجود دارد که هنوز می‌خواهید آن‌ها را نگه دارید. در این مورد، نمی‌توانید شاخه را حذف کنید، اما ادغام کل شاخه نیز مناسب نیست. چه باید کرد؟ این مقاله توضیح می‌دهد که چگونه از دستور `git cherry-pick` برای "انتخاب دستی" تغییراتی که می‌خواهید اعمال کنید، استفاده کنید.

## درک git cherry-pick

گاهی اوقات می‌خواهید کامیت‌های خاصی را از یک شاخه به شاخه دیگر اعمال کنید، بدون اینکه کل شاخه را ادغام کنید. دستور `cherry-pick` گیت دقیقاً به شما اجازه می‌دهد تا همین کار را انجام دهید - کامیت‌ها را به صورت انتخابی بردارید و در شاخه فعلی خود اعمال کنید.

`git cherry-pick` تغییرات ایجاد شده توسط کامیت‌های موجود را در شاخه فعلی شما اعمال می‌کند. این دستور کامیت‌های جدیدی با همان تغییرات اما با هش‌های کامیت متفاوت ایجاد می‌کند.

## استفاده پایه از Cherry-Pick

برای cherry-pick کردن یک کامیت واحد:

```
# به شاخه هدف بروید
git checkout main

# کامیت را انتخاب و اعمال کنید
git cherry-pick <commit-hash>
```

این کار یک کامیت جدید در شاخه فعلی با همان تغییراتِ کامیتِ مشخص شده ایجاد می‌کند.

## Cherry-Picking چندین کامیت

برای cherry-pick کردن چندین کامیت:

```
# چندین کامیت را انتخاب کنید
git cherry-pick <hash1> <hash2> <hash3>
```

برای cherry-pick کردن محدوده‌ای از کامیت‌ها:

```
# انتخاب کامیت‌ها از commit1 تا commit2 (بدون شامل شدن commit1)
git cherry-pick commit1..commit2

# انتخاب کامیت‌ها از commit1 تا commit2 (با شامل شدن commit1)
git cherry-pick commit1^..commit2
```

## Cherry-Pick بدون کامیت کردن

برای اعمال تغییرات بدون ایجاد خودکار کامیت:

```
git cherry-pick --no-commit <commit-hash>
# یا
git cherry-pick -n <commit-hash>
```

این مورد زمانی مفید است که بخواهید چندین کامیت را cherry-pick کرده و یک کامیت واحد ایجاد کنید.

## مدیریت تداخل‌ها (Handling Conflicts)

اگر در حین cherry-pick تداخلی رخ دهد:

```
# تداخل‌ها را در فایل‌ها حل کنید
# فایل‌های حل شده را آماده (stage) کنید
git add <resolved-files>

# فرآیند cherry-pick را ادامه دهید
git cherry-pick --continue
```

برای لغو فرآیند cherry-pick در حال انجام:

```
git cherry-pick --abort
```

برای نادیده گرفتن کامیت فعلی و رفتن به کامیت بعدی:

```
git cherry-pick --skip
```

## Cherry-Pick همراه با ویرایش (Edit)

برای ویرایش پیام کامیت در حین cherry-picking:

```
git cherry-pick -e <commit-hash>
# یا
git cherry-pick --edit <commit-hash>
```

## Cherry-Pick و تایید امضا (Sign-off)

برای اضافه کردن خط sign-off به پیام کامیت:

```
git cherry-pick -s <commit-hash>
# یا
git cherry-pick --signoff <commit-hash>
```

## موارد استفاده کاربردی

### مورد ۱: اعمال Hotfix روی چندین شاخه

```
# اصلاحیه ایجاد شده در شاخه main (کامیت abc123)
git checkout release-1.0
git cherry-pick abc123

git checkout release-2.0
git cherry-pick abc123
```

### مورد ۲: ادغام انتخابی قابلیت‌ها

```
# شاخه قابلیت (Feature branch) دارای کامیت‌های A, B, C, D است
# شما فقط می‌خواهید B و C در شاخه main باشند

git checkout main
git cherry-pick <hash-B> <hash-C>
```

### مورد ۳: بازیابی کامیت‌های از دست رفته

```
# کامیت گم شده را با استفاده از reflog پیدا کنید
git reflog

# آن را به شاخه فعلی cherry-pick کنید
git cherry-pick <lost-commit-hash>
```

## Cherry-Pick در مقابل Merge در مقابل Rebase

**Cherry-pick**:
* به طور انتخابی کامیت‌های خاص را اعمال می‌کند.
* هش‌های کامیت جدید ایجاد می‌کند.
* برای ادغام انتخابی خوب است.

**Merge**:
* کل شاخه‌ها را ترکیب می‌کند.
* تاریخچه کامل را حفظ می‌کند.
* بهترین روش برای ادغام شاخه‌های قابلیت (feature branches).

**Rebase**:
* کامیت‌ها را روی پایه‌ای جدید بازنویسی می‌کند.
* تاریخچه خطی ایجاد می‌کند.
* برای تمیز کردن تاریخچه خوب است.

## بهترین تجربه‌ها (Best Practices)

۱. **با احتیاط استفاده کنید**: cherry-pick در صورت استفاده بیش از حد می‌تواند تاریخچه را گیج‌کننده کند.
۲. **دلیل را مستند کنید**: در پیام کامیت توضیح دهید که چرا cherry-pick کردید.
۳. **از موارد تکراری اجتناب کنید**: کامیت‌هایی را که بعداً ادغام خواهند شد، cherry-pick نکنید.
۴. **وابستگی‌ها را چک کنید**: مطمئن شوید که کامیت به کامیت‌های دیگر وابسته نیست.
۵. **بعد از cherry-pick تست کنید**: بررسی کنید که تغییرات در بافتِ جدید (context) به درستی کار می‌کنند.

## ردیابی کامیت‌های Cherry-Picked

گیت می‌تواند کامیت‌های cherry-picked را ردیابی کند:

```
# استفاده از پرچم -x هنگام cherry-pick
git cherry-pick -x <commit-hash>
```

این کار خطی را به پیام کامیت اضافه می‌کند: "(cherry picked from commit ...)"

## اشتباهات رایج که باید از آن‌ها اجتناب کرد

۱. **Cherry-picking کامیت‌های ادغام (merge)**: معمولاً باعث ایجاد مشکل می‌شود.
۲. **Cherry-picking از شاخه feature به main**: می‌تواند هنگام ادغام واقعی، کامیت‌های تکراری ایجاد کند.
۳. **تست نکردن**: تغییرات ممکن است در شاخه‌های مختلف رفتار متفاوتی داشته باشند.
۴. **نادیده گرفتن وابستگی‌ها**: ممکن است کامیت انتخاب شده برای کار کردن به کامیت‌های دیگر نیاز داشته باشد.

## خلاصه امروز

`git cherry-pick` ابزار قدرتمندی برای اعمال انتخابی کامیت‌ها از یک شاخه به شاخه دیگر است. به ویژه برای اعمال hotfixها به شاخه‌های انتشارِ متعدد یا انتخاب قابلیت‌های خاص از یک شاخه توسعه مفید است. با این حال، باید با هوشیاری استفاده شود زیرا استفاده بیش از حد از آن می‌تواند تاریخچه را پیچیده کند.

اجازه دهید دستورات گیت و پارامترهای یاد گرفته شده امروز را دوباره سازماندهی کنم:

* git cherry-pick <commit>
* git cherry-pick <commit1> <commit2>
* git cherry-pick commit1..commit2
* git cherry-pick --no-commit
* git cherry-pick -n
* git cherry-pick --continue
* git cherry-pick --abort
* git cherry-pick --skip
* git cherry-pick -e
* git cherry-pick -x
* git cherry-pick --signoff

---

* [بازگشت به فهرست مطالب](README.md)
* [روز قبل: اصلاح تاریخچه نسخه‌های ثبت شده - بخش ۲ (revert)](20.md)
* [روز بعد: اصلاح تاریخچه نسخه‌های ثبت شده - بخش ۴ (rebase)](22.md)

---
