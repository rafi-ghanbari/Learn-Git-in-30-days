# روز ۲۳: اصلاح تاریخچه نسخه‌های ثبت شده - بخش ۵ (rebase 2)

در مقاله قبلی بحث کردیم که Rebase برای "تعیین مجدد نسخه پایه" برای دو شاخه موجود استفاده می‌شود. پس از اجرای Rebase، نقطه شروع شاخه اصلی نیز تغییر می‌کند (نقطه شاخه‌سازی جابجا می‌شود)، که باعث تغییر در نمودار نسخه‌ها می‌شود. با این حال، Rebase می‌تواند کارهای بیشتری انجام دهد - همچنین می‌تواند برای اصلاح اطلاعات نسخه در هر کجای خطِ یک شاخه خاص استفاده شود.

این مقاله ادامه کاوش ما در `git rebase` است و به تکنیک‌های پیشرفته و گردش‌های کاری عملی برای استفاده مؤثر از ری‌بیس، از جمله اصلاح اطلاعات کامیت در یک شاخه می‌پردازد.

## تکنیک‌های پیشرفته ری‌بیس تعاملی

### تقسیم کردن یک کامیت (Splitting a Commit)

برای تقسیم یک کامیت به چندین کامیت:

```
git rebase -i HEAD~3

# کامیت مورد نظر برای تقسیم را با "edit" علامت‌گذاری کنید
# وقتی گیت در آن کامیت متوقف شد:
git reset HEAD^
git add file1
git commit -m "بخش اول"
git add file2
git commit -m "بخش دوم"
git rebase --continue
```

### ترکیب و تغییر ترتیب (Combining and Reordering)

شما می‌توانید هم ترتیب را تغییر دهید و هم کامیت‌ها را در یک عملیات ترکیب کنید:

```
git rebase -i HEAD~5

# در ویرایشگر:
pick abc123 Feature A
squash def456 Fix for A
pick jkl012 Feature C  # جابجا شده به قبل از B
pick ghi789 Feature B  # جابجا شده به بعد از C
fixup mno345 Typo fix for B
```

## ری‌بیس با فرمان Exec

اجرای یک دستور بعد از هر کامیت در طول ری‌بیس:

```
git rebase -i --exec "npm test" HEAD~5
```

این کار `npm test` را بعد از اعمال هر کامیت اجرا می‌کند، که به شما کمک می‌کند بفهمید کدام کامیت باعث شکست تست‌ها شده است.

## ری‌بیس روی یک کامیت خاص (Rebase onto Specific Commit)

به جای نام یک شاخه، می‌توانید روی یک کامیت خاص ری‌بیس کنید:

```
git rebase --onto <new-base-commit> <old-base-commit> <branch>
```

مثال کاربردی - حذف کامیت‌ها از میانه تاریخچه:

```
# حذف کامیت‌های بین B و D
#     A---B---C---D---E feature
# می‌شود:
#     A---B---D'---E' feature

git rebase --onto B D feature
```

## ری‌بیس با گزینه‌های استراتژی (Strategy Options)

استفاده از استراتژی‌های ادغام در طول ری‌بیس:

```
# همیشه نسخه ما را در تداخل‌ها ترجیح بده
git rebase -X ours main

# همیشه نسخه آن‌ها را ترجیح بده
git rebase -X theirs main
```

## حفظ کامیت‌های ادغام (Preserving Merge Commits)

به طور پیش‌فرض، ری‌بیس کامیت‌های ادغام را مسطح (flatten) می‌کند. برای حفظ آن‌ها:

```
git rebase -p main
# یا
git rebase --preserve-merges main
```

توجه: `-p` منسوخ شده است؛ به جای آن از `--rebase-merges` استفاده کنید:

```
git rebase --rebase-merges main
```

## ری‌بیس با Fork-Point

پیدا کردن خودکار نقطه شاخه‌سازی:

```
git rebase --fork-point main
```

این مورد زمانی مفید است که شاخه راه دور Force push شده باشد.

## گردش کار: به‌روز نگه داشتن شاخه قابلیت (Feature Branch)

گردش کار رایج برای آپدیت نگه داشتن شاخه قابلیت با شاخه اصلی (main):

```
# در شاخه قابلیت
git fetch origin
git rebase origin/main

# یا در یک دستور
git pull --rebase origin main
```

## گردش کار: آماده‌سازی برای Pull Request

قبل از ایجاد Pull Request، کامیت‌های خود را تمیز کنید:

```
# ۱. ری‌بیس تعاملی برای تمیز کردن تاریخچه
git rebase -i main

# ۲. فشرده‌سازی کامیت‌های fixup، اصلاح پیام‌ها
# ۳. ارسال با اجبار (Force push) برای آپدیت شاخه خود
git push -f origin feature-branch
```

## گردش کار: آپدیت بعد از بازبینی کد (Code Review)

بعد از دریافت بازخورد در بازبینی کد:

```
# تغییرات را انجام دهید
git add .
git commit --fixup <original-commit>

# ری‌بیس با autosquash
git rebase -i --autosquash main

# آپدیت اجباری شاخه
git push -f origin feature-branch
```

## برخورد با Force Push دیگران

وقتی کسی شاخه‌ای را که شما روی آن کار می‌کنید Force push می‌کند:

```
# شاخه آپدیت شده را دریافت کنید
git fetch origin

# کارهای خود را روی تاریخچه جدید ری‌بیس کنید
git rebase --onto origin/feature-branch old-commit feature-branch
```

یا به سادگی:

```
git pull --rebase origin feature-branch
```

## Rebase در مقابل Reset برای پاکسازی

برای تمیز کردن کامیت‌های محلی قبل از Push:

**Rebase** (توصیه شده):
* ترتیب زمانی را حفظ می‌کند.
* کنترل تعاملی دارد.
* امکان cherry-pick کردن کامیت‌ها را فراهم می‌کند.

**Reset** (ساده‌تر اما با انعطاف کمتر):
* کامیت‌ها را کاملاً حذف می‌کند.
* از وضعیتی تمیز دوباره شروع می‌کند.
* کنترل کمتری روی کامیت‌های فردی دارد.

## الگوهای رایج ری‌بیس

### الگوی ۱: فشرده‌سازی تمام کامیت‌ها

```
git rebase -i --root
# تمام کامیت‌ها بجز اولی را به عنوان "squash" علامت بزنید
```

### الگوی ۲: اصلاح تمام پیام‌های کامیت

```
git rebase -i HEAD~10
# تمام کامیت‌ها را به عنوان "reword" علامت بزنید
```

### الگوی ۳: حذف کامیت‌های خاص

```
git rebase -i HEAD~10
# کامیت‌های ناخواسته را به عنوان "drop" علامت بزنید
```

## چک‌لیست ایمنی ری‌بیس

قبل از ری‌بیس:

- [ ] آیا این کامیت به یک شاخه مشترک Push شده است؟
- [ ] آیا دیگران کار خود را بر اساس این کامیت بنا کرده‌اند؟
- [ ] آیا بکاپ دارم (شاخه یا تگ)؟
- [ ] آیا با تیم هماهنگ کرده‌ام؟
- [ ] آیا برای force-push آماده هستم؟

## بازیابی از فجایع ری‌بیس

اگر اوضاع خوب پیش نرفت:

```
# مرحله ۱: خونسرد باشید
# مرحله ۲: وضعیت قبلی را پیدا کنید
git reflog

# مرحله ۳: به قبل از شروع ری‌بیس بازگردید
git reset --hard HEAD@{5}

# مرحله ۴: دوباره با دقت بیشتر امتحان کنید
```

## ری‌بیس و یکپارچه‌سازی مداوم (Continuous Integration)

هنگام استفاده از CI/CD با ری‌بیس:

۱. **به صورت محلی ری‌بیس کنید** قبل از Push.
۲. **تست‌ها را اجرا کنید** بعد از ری‌بیس.
۳. **Force push** را فقط روی شاخه خودتان انجام دهید.
۴. **منتظر CI بمانید** قبل از ادغام نهایی.
۵. **هرگز ری‌بیس نکنید** بعد از ادغام (merge).

## خلاصه بهترین تجربه‌ها

۱. **فقط محلی**: فقط کامیت‌های Push نشده را ری‌بیس کنید.
۲. **ری‌بیس‌های کوچک**: مکرراً ری‌بیس کنید تا از تداخل‌های بزرگ جلوگیری شود.
۳. **تست همه‌جانبه**: بعد از ری‌بیس، تست‌ها را اجرا کنید.
۴. **ارتباط برقرار کنید**: قبل از force-push، به تیم هشدار دهید.
۵. **بکاپ**: قبل از ری‌بیس‌های اصلی، یک شاخه بکاپ بسازید.
۶. **در مورد -f محتاط باشید**: قبل از force-push همه چیز را دوباره چک کنید.

## خلاصه امروز

تکنیک‌های پیشرفته ری‌بیس به شما ابزارهای قدرتمندی برای حفظ تاریخچه کامیت تمیز و قابل درک می‌دهد. در حالی که این ویژگی‌ها می‌توانند گردش کار شما را به میزان قابل توجهی بهبود بخشند، نیاز به تمرین و استفاده دقیق دارند. کلید موفقیت، دانستن زمان استفاده از rebase و زمان استفاده از جایگزین‌های ایمن‌تر مانند merge است.

اجازه دهید دستورات گیت و پارامترهای یاد گرفته شده امروز را دوباره سازماندهی کنم:

* git rebase --exec
* git rebase --onto
* git rebase -X
* git rebase --preserve-merges
* git rebase --rebase-merges
* git rebase --fork-point
* git rebase --root
* git pull --rebase
* git push -f

---

* [بازگشت به فهرست مطالب](README.md)
* [روز قبل: اصلاح تاریخچه نسخه‌های ثبت شده - بخش ۴ (rebase)](22.md)
* [روز بعد: استفاده از مخزن راه دور GitHub - شروع کار](24.md)

---
